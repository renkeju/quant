# 副本和视图

副本是一个数据的完整拷贝，如果我们对副本进行修改，他不会影响到原始数据，物理内存不在同一位置。

视图是数据的一个别称或引用，通过该别称或引用亦便可访问、操作原有数据，但原有数据不会产生拷贝。如果我们对视图进行修改，它会影响到原始数据，物理内存在同一位置。

视图一般发生在：

1. numpy 的切片操作返回原数据的视图。
2. 调用 ndarray 的 view() 函数产生一个视图。

副本一般发生在：

1. Python 序列的切片操作，调用 deepCopy() 函数。
2. 调用 ndarray 的 copy() 函数产生一个副本。

## 无复制

简单的赋值不会创建数组对象的副本。相反，它使用原始数组的相同id()来访问它。id()返回Python对象的通用标识符，类似于C中的指针。

此外，一个数组的任何变化都反映在另一个数组上。例如，一个数组的形状改变也会改变另一个数组的形状。

```
>>> import numpy as np
>>> a = np.arange(6)
>>> print(a)
[0 1 2 3 4 5]
>>> print(id(a))
140226728682288
>>> b = a
>>> print(b)
[0 1 2 3 4 5]
>>> print(id(b))
140226728682288
>>> b.shape = 3, 2
>>> print(b)
[[0 1]
 [2 3]
 [4 5]]
>>> print(a)
[[0 1]
 [2 3]
 [4 5]]
```

## 视图和浅拷贝

ndarray.view() 方会创建一个新的数组对象，该方法创建的新数组的维数变化不会改变原始数据的维数。

```
>>> import numpy as np
>>> a = np.arange(6).reshape(3, 2)
>>> print(a)
[[0 1]
 [2 3]
 [4 5]]
>>> b = a.view()
>>> print(b)
[[0 1]
 [2 3]
 [4 5]]
>>> print(id(a))
140349686800912
>>> print(id(b))
140349734824240
>>> b.shape = 2, 3
>>> print(b)
[[0 1 2]
 [3 4 5]]
>>> print(a)
[[0 1]
 [2 3]
 [4 5]]
```

使用切片创建视图修改数据会影响到原始数组：

```
>>> import numpy as np
>>> arr = np.arange(12)
>>> print(arr)
[ 0  1  2  3  4  5  6  7  8  9 10 11]
>>> a = arr[3:]
>>> b = arr[3:]
>>> a[1] = 123
>>> b[2] = 234
>>> print(arr)
[  0   1   2   3 123 234   6   7   8   9  10  11]
>>> print(id(a), id(b), id(arr[3:]))
140335054760240 140335018312208 140335054794896
```

变量 a,b 都是 arr 的一部分视图，对视图的修改会直接反映到原数据中。但是我们观察 a,b 的 id，他们是不同的，也就是说，视图虽然指向原数据，但是他们和赋值引用还是有区别的。

## 副本和深拷贝

ndarray.copy() 函数创建一个副本。对副本数据进行修改，不会影响到原始数据，他们物理内存不在同一位置上。

```
>>> import numpy as np
>>> a = np.array([[10, 10], [2, 3], [4, 5]])
>>> print(a)
[[10 10]
 [ 2  3]
 [ 4  5]]
>>> b = a.copy()
>>> print(b)
[[10 10]
 [ 2  3]
 [ 4  5]]
>>> print(b is a)
False
>>> b[0, 0] = 100
>>> print(b)
[[100  10]
 [  2   3]
 [  4   5]]
>>> print(a)
[[10 10]
 [ 2  3]
 [ 4  5]]
```

