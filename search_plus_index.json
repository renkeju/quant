{"./":{"url":"./","title":"Introduction","keywords":"","body":"Quant "},"chapter_1/":{"url":"chapter_1/","title":"Python Library","keywords":"","body":"Python Libary 本章要给大家介绍Python在量化金融中运用最广泛的几个库： NumPy SciPy Pandas matplotlib "},"chapter_1/1.1.numpy.html":{"url":"chapter_1/1.1.numpy.html","title":"NumPy","keywords":"","body":"NumPy 量化分析的工作涉及到大量的数值运算，一个高效方便的科学计算工具是必不可少的。Python语言一开始并不是设计为科学计算使用的语言，随着越来越多的人发现Python的易用性，逐渐出现了关于Python的大量外部扩展，NumPy(Numeric Python)就是其中之一。NumPy提供了大量的数值编程工具，可以方便地处理向量、矩阵等运算，极大的便利人们在科学计算方面的工作。另一方面，Python是免费的，相比于花费高额的费用使用Matlab，Python的出现使得Python得到了更多人的青睐。 NumPy 通常与 SciPy(Scientific Python) 和 Matplotlib（绘图库）一起使用，这种组合广泛用于替代MatLab，是一个强大的科学计算环境，有助于我们通过Python学习数据科学或者机器学习。 "},"chapter_1/1.1.1.install.html":{"url":"chapter_1/1.1.1.install.html","title":"安装","keywords":"","body":"NumPy 安装 Python 官方发行的版本是不包含 NumPy 模块的。我们可以使用一下几种方法来安装。 使用已有的发行版本 对于许多用户，尤其是在 Windows 上，最简单的方法是下载以下的 Python 发行版，它们包含了所有的关键包（包括 NumPy、SciPy、matplotlib、IPython、SymPy 以及 Python 核心自带的其他包）： Anaconda：免费的 Python 发行版，用于进行大规模的数据处理、预测分析和科学计算，致力于简化报的管理和部署。支持 Linux、Windows和Mac系统。 Enthought Canopy：提供了免费和商业发行版。支持 Linux、Windows和Mac系统。 Python(x,y)：免费的Python发行版，包含了完整的Python语言开发包及Spyder IDE。支持 Windows，仅限Python2.0版本。 WinPython：另一个免费的Python发行版，包含科学计算包与Spyder IDE。仅支持 Windows。 Pyzo：基于 Anaconda 的免费发行版本及 IEP 的交互开发环境，超轻量级。支持 Linux、Windows和Mac系统。 使用 pip 安装 安装 NumPy 最简单的方法就是使用pip工具。 pip3 install --user numpy scipy matplotlib --user 选项可以设置只安装在当前用户下，而不是写入到系统目录。 默认情况下使用国外线路，国外很慢，我们使用清华的镜像就可以： pip3 install numpy scipy matplotlib -i https://pypi.tuna.tsinghua.edu.cn/simple Linux 下安装 Debian 系 sudo apt-get install python-numpy python-scipy python-matplotlib ipython ipython-notebook python-pandas python-sympy python-nose Fedora 系 sudo dnf install numpy scipy python-matplotlib ipython python-pandas sympy python-nose atlas-devel MacOS Mac 系统的 Homebrew 不包含 NumPy 或其他一些科学计算包，所以可以使用以下方式来安装： pip3 install numpy scipy matplotlib -i https://pypi.tuna.tsinghua.edu.cn/simple 验证安装 验证是否安装成功 >>> from numpy import * >>> eye(4) array([[1., 0., 0., 0.], [0., 1., 0., 0.], [0., 0., 1., 0.], [0., 0., 0., 1.]]) eye(4) 生成对角矩阵。 "},"chapter_1/1.1.2.ndarray.html":{"url":"chapter_1/1.1.2.ndarray.html","title":"ndarray 对象","keywords":"","body":"NumPy Ndarray 对象 NumPy 最重要的一个特点是其N维数组对象ndarray，它是一系列同类型数据的集合，以0下标为开始进行集合中元素的索引。 ndarray 对象是用于存放同类型元素的多维数组。 ndarray 中的每个元素在内存中都有相同存储大小的区域。 ndarray 内部由以下内容组成： 一个指向数据（内存货内存映射文件中的一块数据）的指针。 数据类型或dtype，描述在数组中的固定大小值的格子。 一个表示数组形状（shape）的元组，表示各个维度大小的元组。 一个跨度元组（stride），其中的整数指的是为了前进到当前维度下一个元素需要“跨过”的字节数。 ndarray的内部结构： 跨度可以是负数，这样会使数组在内存中向后移动，切片中obj[::-1]或obj[:,::-1]就是如此。 创建一个 ndarray只需调用 NumPy 的 array 函数即可： numpy.array(object, dtype = None, copy = True, order = None, subok = False, ndmin = 0) 参数说明： 名称 描述 object 数组或嵌套的数列 dtype 数组元素的数据类型，可选 copy 对象是否需要复制，可选 order 创建数组的样式，C为行方向，F为列方向，A为任意方向（默认） subok 默认返回一个与基类类型一致的数组 ndmin 指定生成数组的最小维度 实例 接下来我们可以通过以下实例帮助我们更好的理解。 >>> import numpy as np >>> a = np.array([1,2,3]) >>> print(a) [1 2 3] 增加一个维度： >>> import numpy as np >>> a = np.array([[1,2], [3,4]]) >>> print(a) [[1 2] [3 4]] 设置最小维度： >>> import numpy as np >>> a = np.array([1,2,3,4,5], ndmin=2) >>> print(a) [[1 2 3 4 5]] 使用 dtype 参数 >>> import numpy as np >>> a = np.array([1,2,3], dtype=complex) >>> print(a) [1.+0.j 2.+0.j 3.+0.j] ndarray对象由计算机内存的连续一维部分组成，并结合索引模式，讲每个元素映射到内存块中的一个位置，内存块以行顺序（C样式）或列顺序（FORTRAN或Matlab风格，即前述的F样式）来保存元素。 "},"chapter_1/1.1.3.datatype.html":{"url":"chapter_1/1.1.3.datatype.html","title":"数据类型","keywords":"","body":"NumPy 数据类型 NumPy 支持的数据类型比 Python 内置的类型要多很多，基本上和C语言的数据类型对应上，其中部分对应为 Python 的内置的类型。下表列举了常用 NumPy 基本类型。 名称 描述 bool_ 布尔型数据类型（True或False） int_ 默认的整数类型（类似与C语言中的long，int32或int64） intc 与C的int类型一样，一般是int32或int64 intp 用于索引的整数类型（类似于C的ssize_t，一般情况下仍然是int32或int64） int8 整数（-128 to 127） int16 整数（-32768 to 32767） int32 整数（-2147483648 to 21473647） int64 整数（-9223372036854775808 to 9223372036854775807） unit8 无符号整数（0 to 255） unit16 无符号整数（0 to 65535） unit32 无符号整数（0 to 4294967295） unit64 无符号整数（0 to 18446744073709551615） float_ float64类型的简写 float16 半精度浮点数，包括：1个符号位，5个指数位，10个尾数位 float32 单精度浮点数，包括：1个符号位，8个指数位，23个尾数位 float64 双精度浮点数，包括：1个符号位，11个指数位，52个尾数位 complex_ complex128类型的简写，即128位复数 complex64 复数，表示双32位浮点数（实数部分和虚数部分） complex128 复数，表示双64位浮点数（实数部分和虚数部分） numpy 的数值类型实际上是dtype对象的实例，并对应唯一的自负，包括 np.bool_，np.int32，np.float32，等等。 数据类型对象（dtype） 数据类型对象（numpy.dtype 类的实例）用来描述与数组对应的内存区域是如何使用，它描述了数据的以下几个方面： 数据的类型（整数，浮点数或者Python对象） 数据的大小（例如，整数使用多少字节存储） 数据的字节顺序（大端法或小端法） 在结构化类型的情况下，字段的名称、每个字段的数据类型和每个字段所取的内存块的部分 如果数据类型是子数组，那么它的形状和数据类型是什么。 字节顺序是通过对数据类型预先设定或>来决定的。意味着小端法（最小值存储在最小的地址，即低位组放在最前面）。>意味着大端法（最重要的字节存储在最小的地址，即高位组放在最前面）。 dtype 对象是使用以下语法构造的： numpy.dtype(object, align, copy) object：要转换为的数据类型对象 align：如果为true，填充字段使其类似C的结构体 copy：复制dtype对象，如果为 false，则是对内置数据类型对象的引用 实例 接下来我们可以通过实例来理解： >>> import numpy as np >>> dt = np.dtype(np.int32) >>> print(dt) int32 int8,int16,int32,int64 四种数据类型可以使用字符串 'i1','i2','i4','i8'代替 >>> import numpy as np >>> dt = np.dtype('i8') >>> print(dt) int64 字节顺序标注 >>> import numpy as np >>> dt = np.dtype('>> print(dt) int64 下面实例展示结构化数据类型的使用，类型字段和对应的实际类型将被创建。 首先创建结构化数据类型： >>> import numpy as np >>> dt = np.dtype([('age', np.int8)]) >>> print(dt) [('age', 'i1')] 将数据类型应用于 ndarray 对象 >>> import numpy as np >>> dt = np.dtype([('age', np.int8)]) >>> a = np.array([(10,), (20,), (30,)], dtype = dt) >>> print(a) [(10,) (20,) (30,)] 类型字段名可以用于存取实际的 age 列 >>> import numpy as np >>> dt = np.dtype([('age', np.int8)]) >>> a = np.array([(10,), (20,), (30,)], dtype = dt) >>> print(a['age']) [10 20 30] 下面的示例定义一个结构化数据类型 student，包含字符串字段name，整数字段age，及浮点字段marks，并将这个dtype应用到ndarray对象。 >>> import numpy as np >>> student = np.dtype([('name', 'S20'), ('age', 'i1'), ('marks', 'f4')]) >>> print(student) [('name', 'S20'), ('age', 'i1'), ('marks', '>>> import numpy as np >>> student = np.dtype([('name', 'S20'), ('age', 'i1'), ('marks', 'f4')]) >>> a = np.array([('abc', 21, 50), ('xyz', 18, 75)], dtype = student) >>> print(a) [(b'abc', 21, 50.) (b'xyz', 18, 75.)] 每个内建类型都有一个唯一定义它的字符代码，如下： 字符 对应类型 b 布尔型 i （有符号）整型 u 无符号整形integer f 浮点型 c 复数浮点型 m timedelta（时间间隔） M datetime（日期间隔） O （Python）对象 S, a （byte-）字符串 U Unicode V 原始数据（void） "},"chapter_1/1.1.4.array_property.html":{"url":"chapter_1/1.1.4.array_property.html","title":"数组属性","keywords":"","body":"NumPy 数组属性 NumPy 数组的维数称为秩（rank），秩就是轴的数量，即数组的维度，一维数组的秩为1，二维数组的秩为2，以此类推。 在 NumPy 中，每一个线性的数组称为一个轴（axis），也就是维度（dimensions）。比如说，二维数组相当于是两个一维数组，其中第一个一维数组中每个元素又是一个一维数组。所以一维数组就是NumPy中的轴（axis），第一个轴相当于是底层数组，第二个轴是底层数组里的数组。而轴的数量——秩，就是数组的维数。 很多时候可以声明 axis。axis=0，表示沿着第0轴进行操作，即对每一列进行操作；axis=1，表示沿着第1轴进行操作，即对每一行进行操作。NumPy的数组中比较重要 ndarray 对象属性有： 属性 说明 ndarray.ndim 秩，即轴的数量或维度的数量 ndarray.shape 数组的维度，对于矩阵，n行m列 ndarray.size 数组元素的总个数，相当于.shape中n*m的值 ndarray.dtype ndarray对象的元素类型 ndarray.itemsize ndarray对象中每个元素的大小，以字节为单位 ndarray.flags ndarray对象的内存信息 ndarray.real ndarray元素的实部 ndarray.imag ndarray元素的虚部 ndarray.data 包含实际数组元素的缓冲区，由于一般通过数组的索引获取元素，所以通常不需要使用这个属性 ndarray.ndim ndarray.ndim 用于返回数组的维数，等于秩。 >>> import numpy as np >>> a = np.arange(24) >>> print(a.ndim) 1 # a 现在只有一个维度 >>> b = a.reshape(2,3,4) # 调整其维度大小 >>> print(b.ndim) 3 # b 现在拥有三个维度 ndarray.shape ndarray.shape 表示数组的维度，返回一个元组，这个元组的长度就是维度的数目，即 ndim 属性（秩）。比如，一个二维数组，其维度表示“行数”和“列数”。 ndarray.shape 也可以用于调整数组的大小。 >>> import numpy as np >>> a = np.array([[1, 2, 3], [4, 5, 6]]) >>> print(a.shape) (2, 3) 调整数组大小 >>> import numpy as np >>> a = np.array([[1, 2, 3], [4, 5, 6]]) >>> a.shape = (3, 2) >>> print(a) [[1 2] [3 4] [5 6]] NumPy 也提供了 reshape 函数来调整数组大小。 >>> import numpy as np >>> a = np.array([[1, 2, 3], [4, 5, 6]]) >>> b = a.reshape(3,2) >>> print(b) [[1 2] [3 4] [5 6]] ndarray.itemsize ndarray.itemsize 以字节的形式返回数组中每一个元素的大小。 例如，一个元素类型为 float64 的数组 itemsize 属性值为8（float64 占用 64个bit，每个字节长度为8，所以 64/8，占用8个字节），又如，一个元素类型为 complex32 的数组 item 属性为 4(32/8)。 >>> import numpy as np >>> x = np.array([1, 2, 3, 4, 5], dtype = np.int8) >>> print(x.itemsize) 1 >>> x = np.array([1, 2, 3, 4, 5], dtype = np.float64) >>> print(x.itemsize) 8 ndarray.flags ndarray.flags 返回 ndarray 对象的内存信息，包含一下属性： 属性 描述 C_CONTIGUOUS(C) 数据是在一个单一的C风格的连续段中 F_CONTIGUOUS(F) 数据是在一个单一的Fortran风格的连续段中 OWNDATA(O) 数组拥有它所使用的内存或从另一个对象中借用它 WRITEABLE(W) 数据区域可以被写入，将该值设置为 False，则数据为只读 ALIGNED(A) 数据和所有元素都适当地对齐到硬件上 UPDATEIFCOPY(U) 这个数组是其它数组的一个副本，当这个数组被释放时，原数组的内容将被更新 >>> import numpy as np >>> x = np.array([1, 2, 3, 4, 5]) >>> print(x.flags) C_CONTIGUOUS : True F_CONTIGUOUS : True OWNDATA : True WRITEABLE : True ALIGNED : True WRITEBACKIFCOPY : False UPDATEIFCOPY : False "},"chapter_1/1.1.5.create_array.html":{"url":"chapter_1/1.1.5.create_array.html","title":"创建数组","keywords":"","body":"NumPy 创建数组 ndarray 数组除了可以使用底层的 ndarray 构造器来创建外，也可以通过一下几种方式来创建。 numpy.empty numpy.empty 方式用来创建一个指定形状（shape）、数据类型（dtype）且未初始化的数组： numpy.empty(shape, dtype = float, order = 'C') 参数说明： 参数 描述 shape 数据形状 dtype 数据类型，可选 order 有“C”和“F”两个选项，分别代表，行优先和列优先，在计算机内存中的存储元素的顺序。 下面是一个创建空数组的实例： >>> import numpy as np >>> x = np.empty([3, 2], dtype = int) >>> print(x) [[7290888465049002104 3184989590875566189] [8751730065233752608 8389758743023215984] [ 140432562457129 960341802483709]] 注意：数组元素为随机值，因为它们未初始化。 numpy.zeros 创建指定大小的数组，数组元素以0来填充： numpy.zeros(shape, dtype = float, order = \"C\") 参数说明： 参数 描述 shape 数据形状 dtype 数据类型，可选 order 有“C”和“F”两个选项，分别代表，行优先和列优先，在计算机内存中的存储元素的顺序。 >>> import numpy as np >>> x = np.zeros(5) >>> print(x) [0. 0. 0. 0. 0.] >>> y = np.zeros((5,), dtype = np.int8) >>> print(y) [0 0 0 0 0] >>> z = np.zeros((2,2,), dtype = [('x', 'i4'), ('y', 'i4')]) >>> print(z) [[(0, 0) (0, 0)] [(0, 0) (0, 0)]] numpy.ones 创建指定形状的数组，数组元素以1来填充： 参数说明： 参数 描述 shape 数据形状 dtype 数据类型，可选 order 有“C”和“F”两个选项，分别代表，行优先和列优先，在计算机内存中的存储元素的顺序。 >>> import numpy as np >>> x = np.ones(5) >>> print(5) 5 >>> x = np.ones([2, 2], dtype = int) >>> print(x) [[1 1] [1 1]] "},"chapter_1/1.1.6.Create_an_array_from_an_existing_array.html":{"url":"chapter_1/1.1.6.Create_an_array_from_an_existing_array.html","title":"从已有数组创建数组","keywords":"","body":"NumPy 从已有的数组创建数组 numpy.asarray numpy.asarray 类似 numpy.array，但 numpy.asarray 参数只有三个，比 numpy.array 少两个。 numpy.asarray(a, dtype = None, order = None) 参数说明： 参数 描述 a 任意形式的输入参数，可以是，列表，列表的元组，元组，元组的元组，元组的列表，多维数组 dtype 数据类型，可选 order 可选，有“C”和“F”两个选项，分别代表，行优先和列优先，在计算机内存中的存储元素的顺序。 将列表转换为 ndarray： >>> import numpy as np >>> x = [1, 2, 3] >>> a = np.asarray(x) >>> print(a) [1 2 3] 将元组转换为 ndarray： >>> import numpy as np >>> x = (1, 2, 3) >>> a = np.asarray(x) >>> print(x) (1, 2, 3) 将元组列表转换为 ndarray： >>> import numpy as np >>> x = [(1, 2, 3), (4, 5)] >>> a = np.asarray(x) >>> print(a) [(1, 2, 3) (4, 5)] 设置了 dtype 参数： >>> import numpy as np >>> x = [1, 2, 3] >>> a = np.asarray(x, dtype = float) >>> print(a) [1. 2. 3.] numpy.frombuffer numpy.frombuffer 用于实现动态数组。 numpy.frombuffer 接收 buffer 输入参数，以流的形式读入转化成 ndarray 对象。 numpy.frombuffer(buffer, dtype = float, count = -1, offset = 0) 注意：buffer 是字符串的时候，Python3 默认 str 是 Unicode 类型，所以要转成 butestring 在原 str 前加上 b。 参数说明： 参数 描述 buffer 可以是任意对象，会以流的形式读入。 dtype 返回数组的数据类型，可选 count 读取的数据数量，默认为-1，读取所有数据。 offset 读取的起始位置，默认为0。 >>> import numpy as np >>> s = b\"Hello World\" >>> a = np.frombuffer(s, dtype = 'S1') >>> print(a) [b'H' b'e' b'l' b'l' b'o' b' ' b'W' b'o' b'r' b'l' b'd'] numpy.fromiter numpy.fromiter 方法从可迭代对象中建立 ndarray 对象，返回一维数组。 numpy.fromiter(iterable, dtype, count=-1) 参数 描述 iterable 可迭代对象 dtype 返回数组的数据类型 count 读取的数据数量，默认为-1，读取所有数据 >>> import numpy as np >>> list = range(5) >>> it = iter(list) >>> x = np.fromiter(it, dtype = float) >>> print(x) [0. 1. 2. 3. 4.] "},"chapter_1/1.1.7.Create_an_array_from_a_numeric_range.html":{"url":"chapter_1/1.1.7.Create_an_array_from_a_numeric_range.html","title":"从数值范围创建数组","keywords":"","body":"NumPy 从数值范围创建数组 numpy.arange numpy 包中的使用 arange 函数创建数值范围并返回 ndarray 对象，函数格式如下： numpy.arange(start, stop, step, dtype) 根据 start 与 stop 指定的范围以及 step 设定的步长，生成一个 ndarray。 参数说明： 参数 描述 start 起始值，默认为0 stop 终止值（不包含） step 步长，默认为1 dtype 返回ndarray的数据类型，如果没有提供，则会使用输入数据的类型 生成 0 到 5 的数组： >>> import numpy as np >>> x = np.arange(5) >>> print(x) [0 1 2 3 4] 设置返回类型位 float： >>> import numpy as np >>> x = np.arange(5, dtype = float) >>> print(x) [0. 1. 2. 3. 4.] 设置了起始值、终止值及步长： >>> import numpy as np >>> x = np.arange(10,20,2) >>> print(x) [10 12 14 16 18] numpy.linspace numpy.linspace 函数用于创建一个一维数组，数组是一个等差数列构成的，格式如下： np.linspace(start, stop, num = 50, endpoint = True, retstep = False, dtype = None) 参数说明： 参数 描述 start 序列的起始值 stop 序列的终止值，如果endpoint为true，该值包含与数列中 num 要生成的等步长的样本数量，默认为50 endpoint 该值为true时，数列中包含stop值，反之不包含，默认是True。 retstep 如果为True时，生成的数组中会显示间距，反之不显示。 dtype ndarray的数据类型 以下实例用到三个参数，设置为起点为1，终止点为10，数列个数为10。 >>> import numpy as np >>> a = np.linspace(1, 10, 10) >>> print(a) [ 1. 2. 3. 4. 5. 6. 7. 8. 9. 10.] 设置元素全部是1的等差数列： >>> import numpy as np >>> a = np.linspace(1, 1, 10) >>> print(a) [1. 1. 1. 1. 1. 1. 1. 1. 1. 1.] 将 endpoint 设为 false，不包含终止值： >>> import numpy as np >>> a = np.linspace(10, 20, 5, endpoint = False) >>> print(a) [10. 12. 14. 16. 18.] 如果将 endpoint 设为 true，则会包含 20。 以下实例设置间距。 >>> import numpy as np >>> a = np.linspace(1, 10, 10, retstep = True) >>> print(a) (array([ 1., 2., 3., 4., 5., 6., 7., 8., 9., 10.]), 1.0) >>> b = np.linspace(1, 10, 10).reshape([10, 1]) >>> print(b) [[ 1.] [ 2.] [ 3.] [ 4.] [ 5.] [ 6.] [ 7.] [ 8.] [ 9.] [10.]] numpy.logspace numpy.logspace 函数用于创建一个于等比数列。格式如下： np.logspace(start, stop, num = 50, endpint = True, base = 10.0, dtype = None) base 参数意思是取对数的时候 log 的下标。 参数 描述｜ start 序列的起始值为：base ** start stop 序列的终止值为：base ** stop。如果 endpoint 为 true，该值包含于数列中 num 要生成的等步长的样本数量，默认为50 endpoint 该值为 true 时，数列中包含的 stop 值，反之不包含，默认是 True base 对数 log 的底数 dtype ndarray的数据类型 >>> import numpy as np >>> a = np.logspace(1.0, 2.0, num = 10) >>> print(a) [ 10. 12.91549665 16.68100537 21.5443469 27.82559402 35.93813664 46.41588834 59.94842503 77.42636827 100. ] 将对数的底数设置为2： >>> import numpy as np >>> a = np.logspace(0, 9, 10, base = 2, dtype = 'int16') >>> print(a) [ 1 2 4 8 16 32 64 128 256 512] "},"chapter_1/1.1.8.Slice_and_index.html":{"url":"chapter_1/1.1.8.Slice_and_index.html","title":"切片和索引","keywords":"","body":"NumPy 切片和索引 ndarray 对象的内容可以通过索引或切片来访问和修改，与Python中list的切片操作一样。 ndarray 数组可以基于 0 - n 的下标进行检索，切片对象可以通过内置的 slice 函数，并设置 start，stop 及 step 参数进行，从原数组中切割出一个新数组。 >>> import numpy as np >>> a = np.arange(10) >>> s = slice(2, 7, 2) >>> print(a[s]) [2 4 6] 以上实例中，我们首先通过 arange() 函数创建 ndarray 对象。然后，分别设置起始，终止和步长的参数为 2、7和2。 我们也可以通过冒号分割切片参数 start:stop:step 来进行切片操作： >>> import numpy as np >>> a = np.arange(10) >>> b = a[2:7:2] >>> print(b) [2 4 6] 冒号:的解释：如果置放一个参数，如[2]，将返回与该索引相对应的单个元素。如果为[2:]，表示从该索引开始以后的所有项都将被提取。如果使用了两个参数，如[2:7]，那么则提取两个索引（不包括停止索引）之间的项。 >>> import numpy as np >>> a = np.arange(10) >>> b = a[5] >>> print(b) 5 >>> import numpy as np >>> a = np.arange(10) >>> print(a[2:]) [2 3 4 5 6 7 8 9] >>> import numpy as np >>> a = np.arange(10) >>> print(a[2:5]) [2 3 4] 多维数组同样适用上述索引提取方法： >>> import numpy as np >>> a = np.array([[1, 2, 3], [3, 4, 5], [4, 5, 6]]) >>> print(a) [[1 2 3] [3 4 5] [4 5 6]] >>> print(a[1:]) [[3 4 5] [4 5 6]] 切片还可以包括省略号...，来使选择元组的长度与数组的维度相同。如果在行位置使用省略号，它将返回包含行中的元素的 ndarray。 >>> import numpy as np >>> a = np.array([[1, 2, 3], [3, 4, 5], [4, 5, 6]]) >>> print(a[...,1]) [2 4 5] >>> print(a[1,...]) [3 4 5] >>> print(a[...,1:]) [[2 3] [4 5] [5 6]] "},"chapter_1/1.1.9.Advanced_index.html":{"url":"chapter_1/1.1.9.Advanced_index.html","title":"高级索引","keywords":"","body":"NumPy 高级索引 NumPy 比一般的Python序列提供更多的索引方式。除了之前看到的用整数和切片的索引外，数组可以由整数数组索引，布尔索引及花式索引。 整数数组索引 以下实例获取数组中的(0,0),(1,1)和(2,0)位置处的元素。 >>> import numpy as np >>> x = np.array([[1, 2], [3, 4], [5, 6]]) >>> y = x[[0, 1, 2], [0, 1, 0]] >>> print(y) [1 4 5] 以下实例获取了 4*3 数组中的四角的元素。行索引是[0,0]和[3,3]，而列索引是[0,2]和[0,2]。 >>> import numpy as np >>> x = np.array([[0, 1, 2], [3, 4, 5], [6, 7, 8],[9, 10, 11]]) >>> print(x) [[ 0 1 2] [ 3 4 5] [ 6 7 8] [ 9 10 11]] >>> rows = np.array([[0,0], [3,3]]) >>> cols = np.array([[0,2], [0,2]]) >>> y = x[rows,cols] >>> print(y) [[ 0 2] [ 9 11]] 返回的结果是包含每个角元素的 ndarray 对象： 可以借助切片:或...与索引数组组合。如下面例子： >>> import numpy as np >>> a = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) >>> b = a[1:3, 1:3] >>> print(b) [[5 6] [8 9]] >>> c = a[1:3, [1, 2]] >>> print(c) [[5 6] [8 9]] >>> d = a[...,1:] >>> print(d) [[2 3] [5 6] [8 9]] 布尔索引 我们可以通过一个布尔数组来索引目标数组。 布尔索引通过布尔运算（如：比较运算符）来获取符合指定条件的元素的数组。 以下实例获取大于5的元素： >>> import numpy as np >>> x = np.array([[0, 1, 2], [3, 4, 5], [6, 7, 8], [9 ,10, 11]]) >>> print(x) [[ 0 1 2] [ 3 4 5] [ 6 7 8] [ 9 10 11]] >>> print(x[x > 5]) [ 6 7 8 9 10 11] 以下实例使用了 ~（取补运算符）来过滤NaN。 >>> import numpy as np >>> a = np.array([np.nan, 1, 2, np.nan, 3, 4, 5]) >>> print(a[~np.isnan(a)]) [1. 2. 3. 4. 5.] 一下实例演示如何从数组中过滤掉非复数元素。 >>> import numpy as np >>> a = np.array([1, 2+6j, 5, 3.5+5j]) >>> print(a[np.iscomplex(a)]) [2. +6.j 3.5+5.j] 花式索引 花式索引指的是利用整数数组进行索引。 花式索引根据索引数组的值作为目标数组的某个轴的下标来取值。对于使用一维整数数组作为索引，如果目标是一维数组，那么索引的结果就是对应下标的行，如果目标是二维数组，那么就是对应位置的元素。 花式索引根切片不一样，它总是将数据复制到新数组中。 传入顺序索引数组 >>> import numpy as np >>> x = np.arange(32).reshape((8,4)) >>> print(x) [[ 0 1 2 3] [ 4 5 6 7] [ 8 9 10 11] [12 13 14 15] [16 17 18 19] [20 21 22 23] [24 25 26 27] [28 29 30 31]] >>> print(x[[4,2,1,7]]) [[16 17 18 19] [ 8 9 10 11] [ 4 5 6 7] [28 29 30 31]] 传入倒序索引数组 >>> import numpy as np >>> x = np.arange(32).reshape((8, 4)) >>> print(x) [[ 0 1 2 3] [ 4 5 6 7] [ 8 9 10 11] [12 13 14 15] [16 17 18 19] [20 21 22 23] [24 25 26 27] [28 29 30 31]] >>> print(x[[-4, -2, -1, -7]]) [[16 17 18 19] [24 25 26 27] [28 29 30 31] [ 4 5 6 7]] 传入多个索引数组 >>> import numpy as np >>> x = np.arange(32).reshape((8,4)) >>> print(x) [[ 0 1 2 3] [ 4 5 6 7] [ 8 9 10 11] [12 13 14 15] [16 17 18 19] [20 21 22 23] [24 25 26 27] [28 29 30 31]] >>> print(x[np.ix_([1,5,7,2],[0, 3, 1, 2])]) [[ 4 7 5 6] [20 23 21 22] [28 31 29 30] [ 8 11 9 10]] "},"chapter_1/1.1.10.Broadcast.html":{"url":"chapter_1/1.1.10.Broadcast.html","title":"广播","keywords":"","body":"广播 广播（Broadcast）是 numpy 对不同形状（shape）的数组进行数值计算的方式，对数组的算术运算通常在相应的元素上进行。 如果两个数组 a 和 b 形状相同，即满足 a.shape == b.shap，那么 a*b 的结果就是 a 与 b 数组对应位相乘，且各维度的长度相同。 >>> import numpy as np >>> a = np.array([1, 2, 3, 4]) >>> b = np.array([10, 20, 30, 40]) >>> c = a * b >>> print(c) [ 10 40 90 160] 当运算中的2个数组的形状不同时，numpy 将自动触发广播机制。如： >>> import numpy as np >>> a = np.array([[0, 0, 0], [10, 10, 10], [20, 20, 20], [30, 30, 30], [40, 40, 40]]) >>> b = np.array([1, 2, 3]) >>> print(a + b) [[ 1 2 3] [11 12 13] [21 22 23] [31 32 33] [41 42 43]] 4x3 的二维数组与长为3的一维数组相加，等效于把数组b在二维上重复4次再运算： >>> import numpy as np >>> a = np.array([[0,0,0], [10,10,10], [20,20,20], [30,30,30]]) >>> b = np.array([1, 2, 3]) >>> bb = np.tile(b, (4, 1)) >>> print(b) [1 2 3] >>> print(bb) [[1 2 3] [1 2 3] [1 2 3] [1 2 3]] >>> print(a + bb) [[ 1 2 3] [11 12 13] [21 22 23] [31 32 33]] 广播的规则： 让所有输入数组都想其中形状最长的数组看齐，形状中不足的部分都通过在前面加1补齐。 输出数组的形式时输入数组形状的各个维度上的最大值。 如果输入数组的某个维度和输出数组的对应维度的长度相同或者其长度为1时，这个数组能够用来计算，否则出错。 当输入数组的某个维度的长度为1时，沿着此维度运算时都用此维度上的第一组值。 简单理解：对两个数组，分别比较它们的每一个维度（若其中一个数组没有当前维度则忽略），满足： 数组拥有相同形状。 当前维度的值相等。 当前维度的值有一个是1。 若条件不满足，抛出ValueError: frames are not aligned异常。 "},"chapter_1/1.1.11.Iterative_array.html":{"url":"chapter_1/1.1.11.Iterative_array.html","title":"迭代数组","keywords":"","body":"迭代数组 NumPy 迭代器对象 numpy.nditer 提供了一种灵活访问一个或多个数组元素的方式。 迭代器最基本的任务的可以完成对数组元素的访问。 接下来我们使用 arange() 函数创建一个 2X3 数组，并使用 nditer 对它进行迭代。 >>> import numpy as np >>> a = np.arange(6).reshape(2,3) >>> print(a) [[0 1 2] [3 4 5]] >>> for x in np.nditer(a): ... print(x, end=\",\") ... 0,1,2,3,4,5,>>> 以上实例不是使用标准C或者Fortran顺序，选择的顺序是和数组内存布局一致的，这样做是为了提升访问的效率，默认是行序优先（row-major order，或者说是 C-order） 这反映了默认情况下只需访问每个元素，而无需考虑其特定顺序。我们可以通过迭代上述数组的转置来核对这一点，并与以C顺序访问数组转置的 copy 方式做对比，如下实例： >>> import numpy as np >>> a = np.arange(6).reshape(2, 3) >>> for x in np.nditer(a.T): ... print(x, end=\",\") ... 0,1,2,3,4,5, >>> for x in np.nditer(a.T.copy(order='C')): ... print(x, end=\",\") ... 0,3,1,4,2,5, 从上述例子可以看出，a 和 a.T 的遍历顺序是一样的，也就是它们在内存中的存储顺序也是一样的。但是a.T.copy(order='C')的遍历结果是不同的，那是因为它和前两种的存储方式是不一样的，默认是按行访问。 控制遍历顺序 for x in np.nditer(a, order='F')：Fortran order，即是列序优先； for x in np.nditer(a.T, order='C')：C order，即是行序优先； >>> import numpy as np >>> a = np.arange(0, 60, 5) >>> print(a) [ 0 5 10 15 20 25 30 35 40 45 50 55] >>> a = a.reshape(3, 4) >>> print(a) [[ 0 5 10 15] [20 25 30 35] [40 45 50 55]] >>> b = a.T >>> print(b) [[ 0 20 40] [ 5 25 45] [10 30 50] [15 35 55]] >>> c = b.copy(order='C') >>> print(c) [[ 0 20 40] [ 5 25 45] [10 30 50] [15 35 55]] >>> for x in np.nditer(c): ... print(x, end=\",\") ... 0,20,40,5,25,45,10,30,50,15,35,55, >>> c = b.copy(order='F') >>> print(c) [[ 0 20 40] [ 5 25 45] [10 30 50] [15 35 55]] >>> for x in np.nditer(c): ... print(x, end=\",\") ... 0,5,10,15,20,25,30,35,40,45,50,55, 可以通过显式设置，来强制 nditer 对象使用某种顺序： >>> import numpy as np >>> a = np.arange(0,60,5) >>> a = a.reshape(3,4) >>> print(a) [[ 0 5 10 15] [20 25 30 35] [40 45 50 55]] >>> for x in np.nditer(a, order = 'C'): ... print(x, end=\",\") ... 0,5,10,15,20,25,30,35,40,45,50,55, >>> for x in np.nditer(a, order = 'F'): ... print(x, end=\",\") ... 0,20,40,5,25,45,10,30,50,15,35,55, 修改数组中元素的值 nditer 对象有另一个可选参数op_flags。默认情况下，nditer将视待迭代遍历的数组为只读对象（read-only），为了在遍历数组的同时，实现对数组元素值的修改，必须制定 read-write 或者 write-only 的模式。 >>> import numpy as np >>> a = np.arange(0, 60, 5) >>> a = a.reshape(3,4) >>> print(a) [[ 0 5 10 15] [20 25 30 35] [40 45 50 55]] >>> for x in np.nditer(a, op_flags=['readwrite']): ... x[...]=2 * x ... >>> print(a) [[ 0 10 20 30] [ 40 50 60 70] [ 80 90 100 110]] 使用外部循环 nditer 类的构造器拥有 flags 参数，它可以接受下列值： 参数 描述 c_index 可以跟踪C顺序的索引 f_index 可以跟踪 Fortran 顺序的索引 multi_index 每次迭代可以跟踪一种索引类型 external_loop 给出的值是具有多个值的一维数组，而不是零维数组 在下面的实例中，迭代器遍历对应于每列，并组合为一维数组。 >>> import numpy as np >>> a = np.arange(0,60,5) >>> a = a.reshape(3,4) >>> print(a) [[ 0 5 10 15] [20 25 30 35] [40 45 50 55]] >>> for x in np.nditer(a, flags = ['external_loop'], order = 'F'): ... print(x, end=\",\") ... [ 0 20 40],[ 5 25 45],[10 30 50],[15 35 55], 广播迭代 如果两个数组是可广播的，nditer 组合对象能够同时迭代它们。假设数组a的维度为 3x4，数组b的维度为 1x4，则使用一下迭代器（数组b被广播到a的大小）。 >>> import numpy as np >>> a = np.arange(0,60,5) >>> a = a.reshape(3,4) >>> print(a) [[ 0 5 10 15] [20 25 30 35] [40 45 50 55]] >>> b = np.array([1, 2, 3, 4], dtype = int) >>> print(b) [1 2 3 4] >>> for x,y in np.nditer([a, b]): ... print(\"%d:%d\" % (x, y), end=\",\") ... 0:1,5:2,10:3,15:4,20:1,25:2,30:3,35:4,40:1,45:2,50:3,55:4, "},"chapter_1/1.1.12.Array_operation.html":{"url":"chapter_1/1.1.12.Array_operation.html","title":"数组操作","keywords":"","body":"数组操作 NumPy 中包含了一些函数用于处理数组，大概可分为以下几类： 修改数组形状 翻转数组 修改数组维度 连接数组 分割数组 数组元素的添加与删除 修改数组形状 函数 描述 reshape 不改变数据的条件下修改形状 flat 数组元素迭代器 flatten 返回一份数组拷贝，对拷贝所做的修改不会影响原始数组 ravel 返回展开数组 numpy.reshape numpy.reshape 函数可以在不改变数据的条件下修改形状，格式如下：numpy.reshape(arr, newshape, order='C') arr：要修改形状的数组 newshape：整数或者整数数组，新的形状应当兼容原有形状。 order：'C'--按行；'F'--按列；'A'--原顺序，'K'--元素在内存中的出现顺序。 >>> import numpy as np >>> a = np.arange(8) >>> print(a) [0 1 2 3 4 5 6 7] >>> b = a.reshape(4, 2) >>> print(b) [[0 1] [2 3] [4 5] [6 7]] numpy.ndarray.flat numpy.ndarray.flat 是一个数组元素迭代器，实例如下： >>> import numpy as np >>> a = np.arange(9).reshape(3,3) >>> for row in a: ... print(row) ... [0 1 2] [3 4 5] [6 7 8] >>> for element in a.flat: ... print(element) ... 0 1 2 3 4 5 6 7 8 numpy.ndarray.flatten numpy.ndarray.flatten 返回一份数组拷贝，对拷贝所做的修改不会影响原始数组，格式如下： ndarray.flatten(order='C') 参数说明： order：'C'--按行，'F'--按列，'A'--原顺序，'K'--元素在内存中出现的顺序。 >>> import numpy as np >>> a = np.arange(8).reshape(2,4) >>> print(a) [[0 1 2 3] [4 5 6 7]] >>> print(a.flatten()) [0 1 2 3 4 5 6 7] >>> print(a.flatten(order='F')) [0 4 1 5 2 6 3 7] numpy.ravel numpy.ravel() 展平的数组元素，顺序通常是'C风格'，返回的是数组试图（view，有点类似C/C++引用reference的意味），修改会影响原始数组。 该函数接收两个参数： numpy.revel(a, order='C') 参数说明： order：'C'--按行，'F'--按列，'A'--原顺序，'K'--元素在内存中出现的顺序。 >>> import numpy as np >>> a = np.arange(8).reshape(2,4) >>> print(a) [[0 1 2 3] [4 5 6 7]] >>> print(a.ravel()) [0 1 2 3 4 5 6 7] >>> print(a.ravel(order='F')) [0 4 1 5 2 6 3 7] 翻转数组 函数 描述 transpose 兑换数组的维度 ndarray.T 和self.transpose()相同 rollaxis 先后滚动指定的轴 swapaxes 对换数组的两个轴 numpy.transpose numpy.transpose 函数用于对换数组的维度。格式如下： numpy.transpose(arr, axes) 参数说明： arr：要操作的数组 axes：整数列表，对应维度，通常所有维度都会对换 >>> import numpy as np >>> a = np.arange(12).reshape(3,4) >>> print(a) [[ 0 1 2 3] [ 4 5 6 7] [ 8 9 10 11]] >>> print(np.transpose(a)) [[ 0 4 8] [ 1 5 9] [ 2 6 10] [ 3 7 11]] numpy.ndarray.T 类似 numpy.transpose： >>> import numpy as np >>> a = np.arange(12).reshape(3,4) >>> print(a) [[ 0 1 2 3] [ 4 5 6 7] [ 8 9 10 11]] >>> print(a.T) [[ 0 4 8] [ 1 5 9] [ 2 6 10] [ 3 7 11]] numpy.rollaxis numpy.rollaxis 函数向后滚动特定的轴到一个特定位置，格式如下： numpy.rollaxis(arr, axis, start) 参数说明： arr：数组 axis：要向后滚动的轴，其它轴的相对位置不会改变 start：默认为零，表示完整的滚动。会滚动到特定位置。 >>> import numpy as np >>> a = np.arange(8).reshape(2, 2, 2) >>> print(a) [[[0 1] [2 3]] [[4 5] [6 7]]] >>> print(np.where(a==6)) (array([1]), array([1]), array([0])) >>> print(a[1,1,0]) 6 >>> b = np.rollaxis(a, 2, 0) >>> print(b) [[[0 2] [4 6]] [[1 3] [5 7]]] >>> print(np.where(b==6)) (array([0]), array([1]), array([1])) >>> c = np.rollaxis(a,2,1) >>> print(c) [[[0 2] [1 3]] [[4 6] [5 7]]] >>> print(np.where(c==6)) (array([1]), array([0]), array([1])) numpy.swapaxes numpy.swapaxes 函数用于交换数组的两个轴，格式如下： numpy.swapaxes(arr, axis1, axis2) 参数说明： arr：输入的数组 axis1：对应第一个轴的整数 axis2：对应第二个轴的整数 >>> import numpy as np >>> a = np.arange(8).reshape(2,2,2) >>> print(a) [[[0 1] [2 3]] [[4 5] [6 7]]] >>> print(np.swapaxes(a,2,0)) [[[0 4] [2 6]] [[1 5] [3 7]]] 修改数组维度 维度 描述 broadcast 产生模仿广播的对象 broadcast_to 将数组广播到新形状 expand_dims 扩展数组的形状 squeeze 从数组的形状中阐述一维条目 numpy.broadcast numpy.broadcast 用于模仿广播的对象，它返回一个对象，该对象封装了将一个数组广播到另一个数组的结果。 该函数使用两个数组作为输入参数，如下实例： >>> import numpy as np >>> x = np.array([[1], [2], [3]]) >>> y = np.array([4, 5, 6]) >>> b = np.broadcast(x, y) >>> r, c = b.iters >>> print(next(r), next(c)) 1 4 >>> print(next(r), next(c)) 1 5 >>> print(b.shape) (3, 3) >>> b = np.broadcast(x, y) >>> c = np.empty(b.shape) >>> print(c.shape) (3, 3) >>> c.flat = [u + v for (u, v) in b] >>> print(c) [[5. 6. 7.] [6. 7. 8.] [7. 8. 9.]] >>> print(x + y) [[5 6 7] [6 7 8] [7 8 9]] numpy.broadcast_to numpy.broadcast_to 函数将数组广播到新形状。它在原始数组上返回只读视图。它通常不连续。如果新形状不符合 NumPy 的广播规则，该函数可能会抛出 ValueError。 numpy.broadcast_to(array, shape, subok) >>> import numpy as np >>> a = np.arange(4).reshape(1, 4) >>> print(a) [[0 1 2 3]] >>> print(np.broadcast_to(a,(4,4))) [[0 1 2 3] [0 1 2 3] [0 1 2 3] [0 1 2 3]] numpy.expand_dims numpy.expand_dims 函数通过在指定位置插入新的轴来扩展数组形状，函数格式如下： numpy.expand_dims(arr, axis) 参数说明： arr：输入数组 axis：新轴插入的位置 >>> import numpy as np >>> x = np.array(([1, 2], [3, 4])) >>> print(x) [[1 2] [3 4]] >>> y = np.expand_dims(x, axis = 0) >>> print(y) [[[1 2] [3 4]]] >>> print(x.shape, y.shape) (2, 2) (1, 2, 2) >>> y = np.expand_dims(x, axis = 1) >>> print(y) [[[1 2]] [[3 4]]] >>> print(x.ndim, y.ndim) 2 3 >>> print(x.shape, y.shape) (2, 2) (2, 1, 2) numpy.squeeze numpy.suqeeze 函数葱给定数组的形状中删除一维的条目，函数格式如下： numpy.squeeze(arr, axis) 参数说明： arr：输入数组 axis：整数或整数元组，用于选择形状中一维条目的子集。 >>> import numpy as np >>> x = np.arange(9).reshape(1, 3, 3) >>> print(x) [[[0 1 2] [3 4 5] [6 7 8]]] >>> y = np.squeeze(x) >>> print(y) [[0 1 2] [3 4 5] [6 7 8]] >>> print(x.shape, y.shape) (1, 3, 3) (3, 3) 连接数组 函数 描述 concatenate 连接沿现有轴的数组序列 stack 沿着新的轴加入一系列数组。 hstack 水平堆叠序列中的数组（列方向） vstack 竖直堆叠序列中的数组（行方向） numpy.concatenate numpy.concatenate 函数用于沿指定轴连接相同形状的两个或多个数组。格式如下： numpy.concatenate((a1, a2, ...), axis) 参数说明： a1, a2, ... ：相同类型的数组 axis：沿着它连接数组的轴，默认为0 >>> import numpy as np >>> a = np.array([[1,2], [3,4]]) >>> print(a) [[1 2] [3 4]] >>> b = np.array([[5,6], [7,8]]) >>> print(b) [[5 6] [7 8]] >>> print(np.concatenate((a, b))) [[1 2] [3 4] [5 6] [7 8]] >>> print(np.concatenate((a, b), axis = 1)) [[1 2 5 6] [3 4 7 8]] numpy.stack numpy.stack 函数用于沿新轴连接数组序列，格式如下： numpy.stack(arrays, axis) 参数说明： arrays： 相同形状的数组序列 axis：返回数组中的轴，输入数组沿着它来堆叠 >>> import numpy as np >>> a = np.array([[1, 2], [3, 4]]) >>> print(a) [[1 2] [3 4]] >>> b = np.array([[5, 6], [7, 8]]) >>> print(b) [[5 6] [7 8]] >>> print(np.stack((a, b), 0)) [[[1 2] [3 4]] [[5 6] [7 8]]] >>> print(np.stack((a, b), 1)) [[[1 2] [5 6]] [[3 4] [7 8]]] numpy.hstack numpy.hstack 是 numpy.stack 函数的变体，它通过水平堆叠来生成数组。 >>> import numpy as np >>> a = np.array([[1, 2], [3, 4]]) >>> b = np.array([[5, 6], [7, 8]]) >>> c = np.hstack((a, b)) >>> print(c) [[1 2 5 6] [3 4 7 8]] numpy.vstack numpy.vstack 是 numpy.stack 函数的变体，它通过垂直堆叠来生成数组。 >>> import numpy as np >>> a = np.array(([1, 2], [3, 4])) >>> print(a) [[1 2] [3 4]] >>> b = np.array(([5, 6], [7, 8])) >>> print(b) [[5 6] [7 8]] >>> c = np.vstack((a, b)) >>> print(c) [[1 2] [3 4] [5 6] [7 8]] 分割数组 函数 数组及操作 split 将一个数组分割为多个数组 hsplit 将一个数组水平分割为多个子数组（按列） vsplit 将一个数组垂直分割为多个子数组（按行） numpy.split numpy.split 函数沿特定的轴将数组，格式如下： numpy.split(ary, indices_or_sections, axis) 参数说明： ary：被分割的数组 indices_or_sections：如果是一个整数，就用该数平均切分，如果是一个数组，为沿轴切分的位置（左开右闭） axis：设置沿着哪个方向进行切分，默认为0，横向切分，即水平方向。为1时，纵向切分，即竖直方向。 >>> import numpy as np >>> a = np.arange(9) >>> print(a) [0 1 2 3 4 5 6 7 8] >>> b = np.split(a,3) >>> print(b) [array([0, 1, 2]), array([3, 4, 5]), array([6, 7, 8])] >>> c = np.split(a,[4, 7]) >>> print(c) [array([0, 1, 2, 3]), array([4, 5, 6]), array([7, 8])] asix 为0时在水平方向分割，axis为1时在垂直方向分割。 >>> import numpy as np >>> a = np.arange(16).reshape(4, 4) >>> print(a) [[ 0 1 2 3] [ 4 5 6 7] [ 8 9 10 11] [12 13 14 15]] >>> b = np.split(a, 2) >>> print(b) [array([[0, 1, 2, 3], [4, 5, 6, 7]]), array([[ 8, 9, 10, 11], [12, 13, 14, 15]])] >>> c = np.split(a, 2, 1) >>> print(c) [array([[ 0, 1], [ 4, 5], [ 8, 9], [12, 13]]), array([[ 2, 3], [ 6, 7], [10, 11], [14, 15]])] >>> c = np.hsplit(a, 2) >>> print(c) [array([[ 0, 1], [ 4, 5], [ 8, 9], [12, 13]]), array([[ 2, 3], [ 6, 7], [10, 11], [14, 15]])] numpy.hsplit numpy.hsplit 函数用于水平分割数组，通过指定要返回的相同形状的数组数量来拆分原数组。 >>> import numpy as np >>> harr = np.floor(10 * np.random.random((2, 6))) >>> print(harr) [[8. 9. 2. 4. 0. 8.] [3. 4. 1. 7. 2. 6.]] >>> print(np.hsplit(harr, 3)) [array([[8., 9.], [3., 4.]]), array([[2., 4.], [1., 7.]]), array([[0., 8.], [2., 6.]])] numpy.vsplit numpy.vsplit 沿着垂直轴分割，其分割方式与 hsplit 用法相同。 >>> import numpy as np >>> a = np.arange(16).reshape(4,4) >>> print(a) [[ 0 1 2 3] [ 4 5 6 7] [ 8 9 10 11] [12 13 14 15]] >>> b = np.vsplit(a, 2) >>> print(b) [array([[0, 1, 2, 3], [4, 5, 6, 7]]), array([[ 8, 9, 10, 11], [12, 13, 14, 15]])] 数组元素的添加与删除 函数 元素及描述 resize 返回指定形状的新数组 append 将值天价刀数组末尾 insert 沿指定轴将值插入到指定下标之前 delete 删掉某个轴的子数组，并返回删除后的新数组 unique 查找数组内的唯一元素 numpy.resize numpy.resize 函数返回指定大小的新数组。 如果新数组大小大于原始大小，则包含原始数组中的元素的副本。 numpy.resize(arr, shape) 参数说明： arr：要修改大小的数组 shape：返回数组的新形状 >>> import numpy as np >>> a = np.array([[1, 2, 3], [4, 5, 6]]) >>> print(a) [[1 2 3] [4 5 6]] >>> print(a.shape) (2, 3) >>> b = np.resize(a, (3, 2)) >>> print(b) [[1 2] [3 4] [5 6]] >>> print(b.shape) (3, 2) >>> b = np.resize(a, (3, 3)) >>> print(b) [[1 2 3] [4 5 6] [1 2 3]] numpy.append numpy.append 函数在数组的末尾添加值。追加操作会分配整个数组，并把原来的数组复制到新数组中。此外，输入数组的维度必须匹配否则将生成 ValueError。 append 函数返回的始终是一个一维数组。 append.append(arr, values, axis=None) 参数说明： arr：输入数组 values：要向 arr 添加的值，需要和 arr 形状相同（除了要添加的轴） axis：默认为 None。当 axis 无定义时，是横向加成，返回总是为一维数组！当 axis 有定义的时候，分别为0和1的时候。当 axis 有定义的时候，分别为 0 和 1 的时候（列数要相同）。当 axis 为 1 时，数组是加在左边（列数要相同）。 >>> import numpy as np >>> a = np.array([[1, 2, 3], [4, 5, 6]]) >>> print(a) [[1 2 3] [4 5 6]] >>> print(np.append(a, [7, 8, 9])) [1 2 3 4 5 6 7 8 9] >>> print(np.append(a, [[7,8,9]], axis = 0)) [[1 2 3] [4 5 6] [7 8 9]] >>> print(np.append(a, [[5, 5, 5], [7, 8, 9]], axis = 1)) [[1 2 3 5 5 5] [4 5 6 7 8 9]] numpy.insert numpy.insert 函数在给定索引之前，沿给定轴在输入数组中插入值。 如果值的类型转换为要插入，则它与输入数组不同。插入没有原地的，函数会返回一个新数组。此外，如果未提供轴，则输入数组会被展开。 numpy.insert(arr, obj, values, axis) 参数说明： arr：输入数组 obj：在其之前插入值的索引 values：要插入的值 axis：沿着他插入的轴，如果未提供，则输入数组会被展开 >>> import numpy as np >>> a = np.array([[1,2], [3,4], [5,6]]) >>> print(a) [[1 2] [3 4] [5 6]] >>> print(np.insert(a,3,[11,12])) [ 1 2 3 11 12 4 5 6] >>> print(np.insert(a,1,[11],axis = 0)) [[ 1 2] [11 11] [ 3 4] [ 5 6]] >>> print(np.insert(a,1,11,axis = 1)) [[ 1 11 2] [ 3 11 4] [ 5 11 6]] numpy.delete numpy.delete 函数返回从输入数组中删除指定子数组的新数组。与 insert() 函数的情况一样，如果未提供轴参数，则输入数组将展开。 numpy.delete(arr, obj, axis) 参数说明： arr：输入数组 obj：可以被切片，整数或整数数组，表明要从输入数组删除的子数组。 axis：沿着它删除给定子数组的轴，如果未提供，则输入数组会被展开。 >>> import numpy as np >>> a = np.arange(12).reshape(3, 4) >>> print(a) [[ 0 1 2 3] [ 4 5 6 7] [ 8 9 10 11]] >>> print(np.delete(a,5)) [ 0 1 2 3 4 6 7 8 9 10 11] >>> print(np.delete(a,1,axis = 1)) [[ 0 2 3] [ 4 6 7] [ 8 10 11]] >>> a = np.array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) >>> print(np.delete(a, np.s_[::2])) [ 2 4 6 8 10] numpy.unique numpy.unique 函数用于去除数组中的重复元素。 numpy.unique(arr, return_index, return_inverse, return_counts) 参数： arr：输入数组，如果不是一维数组 return_index：如果为 true，返回新列表元素在旧列表中的位置（下标），并以列表形式储存 return_inverse：如果为 true，返回旧列表元素在新列表中的位置（下标），并以列表形式储存 return_counts：如果为 true，返回去重数组中的元素在原数组中的出现次数。 >>> import numpy as np >>> a = np.array([5,2,6,2,7,5,6,8,2,9]) >>> print(a) [5 2 6 2 7 5 6 8 2 9] >>> u = np.unique(a) >>> print(u) [2 5 6 7 8 9] >>> u, indices = np.unique(a, return_index = True) >>> print(indices) [1 0 2 4 7 9] >>> print(a) [5 2 6 2 7 5 6 8 2 9] >>> u, indices = np.unique(a, return_inverse = True) >>> print(u) [2 5 6 7 8 9] >>> print(indices) [1 0 2 0 3 1 2 4 0 5] >>> print(u[indices]) [5 2 6 2 7 5 6 8 2 9] >>> u, indices = np.unique(a, return_counts = True) >>> print(u) [2 5 6 7 8 9] >>> print(indices) [3 2 2 1 1 1] "},"chapter_1/1.1.13.Bit_operation.html":{"url":"chapter_1/1.1.13.Bit_operation.html","title":"位运算","keywords":"","body":"位运算 NumPy \"bitwise_\" 开头的函数是位运算函数。 NumPy 位运算包括以下几个函数： 函数 描述 bitwise_and 对数组元素执行位与操作 bitwise_or 对数组元素执行位或操作 invert 按位取反 left_shift 向左移动二进制表示的位 right_shift 向右移动二进制表示的位 注：也可以使用“&”、“～”、“｜”和“^”等操作符进行计算。 bitwise_and bitwise_and() 函数对数组中整数的二进制形式执行位与运算。 >>> import numpy as np >>> a, b = 13, 17 >>> print(bin(a), bin(b)) 0b1101 0b10001 >>> print(np.bitwise_and(13, 17)) 1 以上实力可以用于下表来说明： 2^4 2^3 2^2 2^1 2^0 0 1 1 0 1 and 1 0 0 0 1 运算结果 0 0 0 0 1 位与操作运算规律如下： A B AND 1 1 1 1 0 0 0 1 0 0 0 0 invert invert() 函数对数组中整数进行位取反运算，即 0 变成 1，1 变成 0。 对于有符号整数，取该二进制数的补码，然后+1。二进制数，最高位为0表示正数，最高位为1表示负数。 看看 ~1 的计算步骤： 将1（这里叫：原码）转二进制 = 00000001 按位取反 = 11111110 返现符号位（即最高位）为1（表示负数），将除符号位之外的其他数字取反 = 10000001 末位加1取其补码 = 10000010 转换回十进制 = -2 表达式 二进制值（2的补数） 十进制值 5 00000000 00000000 00000000 00000101 5 ~5 11111111 11111111 11111111 111111010 -6 >>> import numpy as np >>> print(np.invert(np.array([13], dtype = np.uint8))) [242] >>> print(np.binary_repr(13, width = 8)) 00001101 >>> print(np.binary_repr(242, width = 8)) 11110010 left_shift left_shift() 函数将数组元素的二进制形式向左移动到指定位置，右侧附加相等数量的 0. >>> import numpy as np >>> print(np.left_shift(10,2)) 40 >>> print(np.binary_repr(10, width = 8)) 00001010 >>> print(np.binary_repr(40, width = 8)) 00101000 right_shift right_shift() 函数将数组元素的二进制形式向右移动到指定位置，左侧附加相等数量的 0。 >>> import numpy as np >>> print(np.right_shift(40,2)) 10 >>> print(np.binary_repr(40,width = 8)) 00101000 >>> print(np.binary_repr(10,width = 8)) 00001010 "},"chapter_1/1.1.14.String_functions.html":{"url":"chapter_1/1.1.14.String_functions.html","title":"字符串函数","keywords":"","body":"字符串函数 以下函数用于对 dtype 为 numpy.string 或 numpy.unicode 的数组执行向量化字符串操作。它们基于 Python 内置库中的标准字符串函数。 这些函数在字符串类组（numpy.char）中定义。 函数 描述 add() 对两个数组的逐个字符串元素进行连接 multiply() 返回按元素多重连接后的字符串 center() 居中字符串 capitalize() 将字符串第一个字母转换为大写 title() 将字符串的每个单词的第一个字母转换为大写 lower() 数组元素转为小写 upper() 数组元素转为大写 split() 指定分隔符对字符串进行分割，并返回数组列表 splitlines() 返回元素中的行列表，以换行符分割 strip() 移除元素开头或者结尾处的特定字符 join() 通过指定分隔符来连接数组中的元素 replace() 使用新字符串替换字符串中的所有子字符串 decode() 数组元素依次调用 str.decode encode() 数组元素依次调用 str.encode numpy.char.add() numpy.char.add() 函数依次对两个数组的元素进行字符串连接。 >>> import numpy as np >>> print(np.char.add(['hello'], ['xyz'])) ['helloxyz'] >>> print(np.char.add(['hello', 'hi'], ['abc', 'xyz'])) ['helloabc' 'hixyz'] numpy.char.multiply() numpy.char.multiply() 函数执行多重连接。 >>> import numpy as np >>> print(np.char.multiply('renkeju ', 3)) renkeju renkeju renkeju numpy.char.center() numpy.char.center() 函数用于将字符串居中，并使用指定字符在左侧和右侧进行填充。 >>> import numpy as np >>> print(np.char.center('renkeju', 20, fillchar = '*')) ******renkeju******* numpy.char.capitalize() numpy.char.capitalize() 函数将字符串的第一个字母转换为大写： >>> import numpy as np >>> print(np.char.capitalize('renkeju')) Renkeju numpy.char.title() numpy.char.title() 函数将字符串的每个单词的第一个字母转换为大写： >>> import numpy as np >>> print(np.char.title('i like you')) I Like You numpy.char.lower() numpy.char.lower() 函数对数组的每个元素转为小写。它对每个元素调用 str.lower。 >>> import numpy as np >>> print(np.char.lower(['RENKEJU', 'GOOGLE'])) ['renkeju' 'google'] >>> print(np.char.lower('RENKEJU')) renkeju numpy.char.upper() numpy.char.upper() 函数对数组的每个数组的元素转换为大写。它对每个元素调用 str.upper。 >>> import numpy as np >>> print(np.char.upper(['renkeju', 'google'])) ['RENKEJU' 'GOOGLE'] >>> print(np.char.upper('google')) GOOGLE numpy.char.split() numpy.char.split() 通过制定分隔符对字符串进行分割，并返回数组。默认情况下，分隔符为空格。 >>> import numpy as np >>> print(np.char.split('i like you?')) ['i', 'like', 'you?'] >>> print(np.char.split('www.renkeju.com', sep = '.')) ['www', 'renkeju', 'com'] numpy.char.splitlines() numpy.char.splitlines() 函数以换行符作为分隔符来分割字符串。并返回数组。 >>> import numpy as np >>> print(np.char.splitlines('i\\nlike you?')) ['i', 'like you?'] >>> print(np.char.splitlines('i\\rlike you?')) ['i', 'like you?'] \\n，\\r，\\r\\n 都可用作换行符。 numpy.char.strip() numpy.char.strip() 函数用于移除开头或结尾的特定字符。 >>> import numpy as np >>> print(np.char.strip('ashok arenkeju', 'a')) shok arenkeju >>> print(np.char.strip(['arenkeju', 'admin', 'java'], 'a')) ['renkeju' 'dmin' 'jav'] numpy.char.join() numpy.char.join() 函数通过指定分隔符来连接数组中的元素或字符串。 >>> import numpy as np >>> print(np.char.join(':', 'renkeju')) r:e:n:k:e:j:u >>> print(np.char.join([':', '-'], ['renkeju', 'google'])) ['r:e:n:k:e:j:u' 'g-o-o-g-l-e'] numpy.char.replace() numpy.char.replace() 函数使用新字符串替换字符串中的所有子字符串。 >>> import numpy as np >>> print(np.char.replace('i like you', 'ou', 'our')) i like your numpy.char.encode() numpy.char.encode() 函数对数组中的每个元素调用 str.encode 函数。默认编码是 utf-8，可以使用标准 Python 库中的编解码器。 >>> import numpy as np >>> a = np.char.encode('renkeju', 'cp500') >>> print(a) b'\\x99\\x85\\x95\\x92\\x85\\x91\\xa4' numpy.char.decode() numpy.char.decode() 函数对编码的元素进行 str.decode() 解码。 >>> import numpy as np >>> a = np.char.encode('renkeju', 'cp500') >>> print(a) b'\\x99\\x85\\x95\\x92\\x85\\x91\\xa4' >>> print(np.char.decode(a, 'cp500')) renkeju "},"chapter_1/1.1.15.Mathematical_functions.html":{"url":"chapter_1/1.1.15.Mathematical_functions.html","title":"数学函数","keywords":"","body":"数学函数 NumPy 包含大量的各种数学运算的函数，包括三角函数，算术运算的函数，复数处理函数等。 三角函数 NumPy 提供了标准的三角函数：sin()、cos()、tan()。 >>> import numpy as np >>> a = np.array([0, 30, 45, 60, 90]) >>> print(np.sin(a * np.pi / 180)) [0. 0.5 0.70710678 0.8660254 1. ] >>> print(np.cos(a * np.pi / 180)) [1.00000000e+00 8.66025404e-01 7.07106781e-01 5.00000000e-01 6.12323400e-17] >>> print(np.tan(a * np.pi / 180)) [0.00000000e+00 5.77350269e-01 1.00000000e+00 1.73205081e+00 1.63312394e+16] arcsin，arccos 和 arctan 函数返回给定角度的 sin，cos 和 tan 的反三角函数。 这些函数的结果可以通过 numpy.degrees() 函数将弧度转换为角度。 >>> import numpy as np >>> a = np.array([0, 30, 45, 60, 90]) >>> sin = np.sin(a * np.pi / 180) >>> print(sin) [0. 0.5 0.70710678 0.8660254 1. ] >>> inv = np.arcsin(sin) >>> print(inv) [0. 0.52359878 0.78539816 1.04719755 1.57079633] >>> print(np.degrees(inv)) [ 0. 30. 45. 60. 90.] >>> cos = np.cos(a * np.pi / 180) >>> print(cos) [1.00000000e+00 8.66025404e-01 7.07106781e-01 5.00000000e-01 6.12323400e-17] >>> inv = np.arccos(cos) >>> print(inv) [0. 0.52359878 0.78539816 1.04719755 1.57079633] >>> print(np.degrees(inv)) [ 0. 30. 45. 60. 90.] >>> tan = np.tan(a * np.pi / 180) >>> print(tan) [0.00000000e+00 5.77350269e-01 1.00000000e+00 1.73205081e+00 1.63312394e+16] >>> inv = np.arctan(tan) >>> print(inv) [0. 0.52359878 0.78539816 1.04719755 1.57079633] >>> print(np.degrees(inv)) [ 0. 30. 45. 60. 90.] 舍入函数 numpy.around() numpy.around() 函数返回指定数字的四舍五入值。 numpy.around(a, decimals) 参数说明： a：数组 decimals：舍入的小数位数。默认值为0。如果为负，整数将四舍五入到小数点左侧的位置。 >>> import numpy as np >>> a = np.array([1.0, 5.55, 123, 0.567, 25.532]) >>> print(a) [ 1. 5.55 123. 0.567 25.532] >>> print(np.around(a)) [ 1. 6. 123. 1. 26.] >>> print(np.around(a, decimals = 1)) [ 1. 5.6 123. 0.6 25.5] >>> print(np.around(a, decimals = -1)) [ 0. 10. 120. 0. 30.] numpy.floor() numpy.floor() 返回小于或等于指定表达式的最大整数，即向下取整。 >>> import numpy as np >>> a = np.array([-1.7, 1.5, -0.2, 0.6, 10]) >>> print(a) [-1.7 1.5 -0.2 0.6 10. ] >>> print(np.floor(a)) [-2. 1. -1. 0. 10.] numpy.ceil() numpy.ceil() 返回大于或者等于指定表达式的最小整数，即向上取整。 >>> import numpy as np >>> a = np.array([-1.7, 1.5, -0.2, 0.6, 10]) >>> print(a) [-1.7 1.5 -0.2 0.6 10. ] >>> print(np.ceil(a)) [-1. 2. -0. 1. 10.] "},"chapter_1/1.1.16.Arithmetic_operations.html":{"url":"chapter_1/1.1.16.Arithmetic_operations.html","title":"算术函数","keywords":"","body":"算术函数 NumPy 算术函数包含简单的加减乘除：add()、subtract()、multiply() 和 divide()。 需要注意的是数组必须具有相同的形状或者符合数组广播规则。 >>> import numpy as np >>> a = np.arange(9, dtype = np.float_).reshape(3, 3) >>> print(a) [[0. 1. 2.] [3. 4. 5.] [6. 7. 8.]] >>> b = np.array([10, 10, 10]) >>> print(b) [10 10 10] >>> print(np.add(a, b)) [[10. 11. 12.] [13. 14. 15.] [16. 17. 18.]] >>> print(np.subtract(a, b)) [[-10. -9. -8.] [ -7. -6. -5.] [ -4. -3. -2.]] >>> print(np.multiply(a, b)) [[ 0. 10. 20.] [30. 40. 50.] [60. 70. 80.]] >>> print(np.divide(a, b)) [[0. 0.1 0.2] [0.3 0.4 0.5] [0.6 0.7 0.8]] 此外 NumPy 也包含了其他重要的算术函数。 numpy.reciprocal() numpy.reciprocal() 函数返回参数逐元素的倒数。如 1/4 倒数为 4/1。 >>> import numpy as np >>> a = np.array([0.25, 1.33, 1, 100]) >>> print(a) [ 0.25 1.33 1. 100. ] >>> print(np.reciprocal(a)) [4. 0.7518797 1. 0.01 ] numpy.power() numpy.power() 函数将第一个输入数组中的元素作为底数，计算它与第二个输入数组中相应元素的幂。 >>> import numpy as np >>> a = np.array([10, 100, 1000]) >>> print(a) [ 10 100 1000] >>> print(np.power(a, 2)) [ 100 10000 1000000] >>> b = np.array([1, 2, 3]) >>> print(b) [1 2 3] >>> print(np.power(a, b)) [ 10 10000 1000000000] numpy.mod() numpy.mod() 计算输入数组中相应元素的相除后的余数。函数 numpy.remainder() 也产生相同的结果。 >>> import numpy as np >>> a = np.array([10, 20, 30]) >>> b = np.array([3, 5, 7]) >>> print(a) [10 20 30] >>> print(b) [3 5 7] >>> print(np.mod(a, b)) [1 0 2] >>> print(np.remainder(a, b)) [1 0 2] "},"chapter_1/1.1.17.Statistical_functions.html":{"url":"chapter_1/1.1.17.Statistical_functions.html","title":"统计函数","keywords":"","body":"统计函数 NumPy 提供了很多统计函数，用于从数组中查找最小元素，最大元素，百分位标准差和方差等。函数说明如下： numpy.amin() 和 numpy.amax() numpy.amin() 用于计算数组中的元素沿指定轴的最小值。 numpy.amax() 用于计算数组中的元素沿指定轴的最大值。 >>> import numpy as np >>> a = np.array([[3, 7, 5], [8, 4, 5], [2, 4, 5]]) >>> print(a) [[3 7 5] [8 4 5] [2 4 5]] >>> print(np.amin(a, 1)) [3 4 2] >>> print(np.amin(a, 0)) [2 4 5] >>> print(np.amax(a)) 8 >>> print(np.amax(a, axis = 0)) [8 7 5] numpy.ptp() numpy.ptp() 函数数组中元素最大值与最小值的差（最大值减去最小值）。 >>> import numpy as np >>> a = np.array([[3, 7, 5], [8, 4, 3], [2, 4, 9]]) >>> print(a) [[3 7 5] [8 4 3] [2 4 9]] >>> print(np.ptp(a)) 7 >>> print(np.ptp(a, axis = 1)) [4 5 7] >>> print(np.ptp(a, axis = 0)) [6 3 6] numpy.percentile() 百分位数是统计中使用的度量，表示小雨这个值的观察值的百分比。函数 numpy.percentile() 接受以下参数。 numpy.percentile(a, q, axis) 参数说明： a：输入数组 q：要计算的百分位数，在 0~100之间 axis：沿着它计算百分位数的轴 首先明确百分位数： 第p个百分位数的这样一个值，它使得至少有 p% 的数据项小于或等于这个值，且至少有(100-p)%的数据项大于或等于这个值。 举个例子：高等院校的入学考试成绩经常以百分位数的形式报告。比如，假设某个考生在入学考试中的语文部分的原始分数为54分。相对于参加同一考试的其他学生来说，他的成绩如何并不容易知道。但是如果原始分数恰好对应的是第70百分位数，我们就能知道大约70%的学生的考分比他低，而约30%的学生考分比他高。 这里的 p = 70。 >>> import numpy as np >>> a = np.array([[10, 7, 4], [3, 2, 1]]) >>> print(a) [[10 7 4] [ 3 2 1]] >>> print(np.percentile(a, 50)) 3.5 >>> print(np.percentile(a, 50, axis=0)) [6.5 4.5 2.5] >>> print(np.percentile(a, 50, axis=1)) [7. 2.] >>> print(np.percentile(a, 50, axis=1, keepdims = True)) [[7.] [2.]] numpy.median() numpy.mediam() 函数用于计算数组 a 中元素的中位数（中值） >>> import numpy as np >>> a = np.array([[30, 65, 70], [80, 95, 10], [50, 90, 60]]) >>> print(a) [[30 65 70] [80 95 10] [50 90 60]] >>> print(np.median(a)) 65.0 >>> print(np.median(a, axis = 0)) [50. 90. 60.] >>> print(np.median(a, axis = 1)) [65. 80. 60.] numpy.mean() numpy.mean() 函数返回数组中元素的算术平均值。如果提供了轴，则沿其计算。 算术平均值是沿轴的元素的总和除以元素的数量。 >>> import numpy as np >>> a = np.array([[1,2,3], [3,4,5], [4,5,6]]) >>> print(a) [[1 2 3] [3 4 5] [4 5 6]] >>> print(np.mean(a)) 3.6666666666666665 >>> print(np.mean(a, axis = 0)) [2.66666667 3.66666667 4.66666667] >>> print(np.mean(a, axis = 1)) [2. 4. 5.] numpy.average() numpy.average() 函数根据在另一个数组中给出的各自的权重计算数组中元素的加权平均值。 该函数可以接受一个轴参数。如果没有指定轴，则数组会被展开。 加权平均值将各数组乘以相应的权数，然后加总求和得到总体值，再除以总的单位数。 考虑数组[1,2,3,4]和相应的权重[4,3,2,1]，通过将相应元素的乘积相加，并将和除以权重的和，来计算加权平均值。 加权平均值 = (1*4+2*3+3*2+4*1)/(4+3+2+1) >>> import numpy as np >>> a = np.array([1,2,3,4]) >>> print(a) [1 2 3 4] >>> print(np.average(a)) 2.5 >>> wts = np.array([4, 3, 2, 1]) >>> print(np.average(a, weights = wts)) 2.0 >>> print(np.average([1, 2, 3, 4], weights = [4, 3, 2, 1], returned = True)) (2.0, 10.0) 在多维数组中，可以指定用于计算的轴。 >>> import numpy as np >>> a = np.arange(6).reshape(3, 2) >>> print(a) [[0 1] [2 3] [4 5]] >>> wt = np.array([3, 5]) >>> print(np.average(a, axis = 1, weights = wt)) [0.625 2.625 4.625] >>> print(np.average(a, axis = 1, weights = wt, returned = True)) (array([0.625, 2.625, 4.625]), array([8., 8., 8.])) 标准差 标准差是一组数据平均值分散程度的一种度量。 标准差是方差的算术平方根。 标准差公式如下： std = sqrt(mean((x - x.mean())**2)) 如果数组是[1, 2, 3, 4]，则其平均值为 2.5。因此，差的平方是[2.25, 0.25, 0.25, 2.25]，并且再求其平均值的平方根除以4，即sqrt(5/4)，结果为 1.118033988749895。 >>> import numpy as np >>> print(np.std([1, 2, 3, 4])) 1.118033988749895 方差 统计中的方差（样本方差）是每个样本值与全体样本值的平均数之差的平方值的平均数，即 mean((x - x.mean())**2)。 换句话说，标准差是方差的平方根。 >>> import numpy as np >>> print(np.var([1, 2, 3, 4])) 1.25 "},"chapter_1/1.1.18.Sort_search.html":{"url":"chapter_1/1.1.18.Sort_search.html","title":"排序、条件刷选函数","keywords":"","body":"排序、条件刷选函数 NumPy 提供了多种排序的方法。这些排序函数实现不同的排序算法，每个排序算法的特征在于执行速度，最坏情况性能，所需的工作空间和算法的稳定性。下表显示了三种排序算法的比较。 种类 速度 最坏情况 工作空间 稳定性 'quicksort'（快速排序） 1 O(n^2) 0 否 'mergesort'（归并排序） 2 O(n*log(n)) ~n/2 是 'heapsort'（堆排序） 3 O(n*log(n)) 0 否 numpy.sort() numpy.sort() 函数返回输入数组的排序副本。函数格式如下： numpy.sort(a, axis, kind, order) 参数说明： a：要排序的数组 axis：沿着它排序数组的轴，如果没有数组会被展开，沿着最后的轴排序，axis=0 按列排序，axis=1 按行排序。 kind：默认为‘quicksort’（快速排序） order：如果数组包含字段，则是要排序的字段。 >>> import numpy as np >>> a = np.array([[3, 7], [9, 1]]) >>> print(a) [[3 7] [9 1]] >>> print(np.sort(a)) [[3 7] [1 9]] >>> print(np.sort(a, axis = 0)) [[3 1] [9 7]] >>> dt = np.dtype([('name', 'S10'), ('age', int)]) >>> a = np.array([('raju',21),('anil',25),('ravi',17),('amar',27)], dtype = dt) >>> print(a) [(b'raju', 21) (b'anil', 25) (b'ravi', 17) (b'amar', 27)] >>> print(np.sort(a, order = 'name')) [(b'amar', 27) (b'anil', 25) (b'raju', 21) (b'ravi', 17)] numpy.argsort() numpy.argsort() 函数返回的是数组值从小到大的索引值。 >>> import numpy as np >>> x = np.array([3, 1, 2]) >>> print(x) [3 1 2] >>> y = np.argsort(x) >>> print(y) [1 2 0] >>> print(x[y]) [1 2 3] >>> for i in y: ... print(x[i], end=\" \") ... 1 2 3 numpy.lexsort() numpy.lexsort() 用于对多个序列进行排序。把它想象成对电子表格进行排序，每一列代表一个序列，排序时有限照顾靠后的列。 这里举一个应用场景：小升初考试，重点班录取学生按照总成绩录取。在总成绩相同时，数学成绩高的优先录取，在总成绩和数学成绩都相同时，按照英语成绩录取…… 这里，总成绩排在电子表格的最后一列，数学成绩在倒数第二列，英语成绩在倒数第三列。 >>> import numpy as np >>> nm = ['raju', 'anli', 'ravi', 'amar'] >>> dv = ['f.y.', 's.y.', 's.y.', 'f.y.'] >>> ind = np.lexsort((dv, nm)) >>> print(ind) [3 1 0 2] >>> print ([nm[i] + \", \" + dv[i] for i in ind]) ['amar, f.y.', 'anli, s.y.', 'raju, f.y.', 'ravi, s.y.'] 上面传入 np.lexsort 的是一个 tuple，排序时首先排 nm，顺序为：amar、anil、raju、ravi。综上排序结果为 [3 1 0 2]。 msort、sort_complex、partition、argpartition 函数 描述 msort(a) 数组按第一个轴排序，返回排序后的数组副本。np.msort(a) 相等于 np.sort(a, axis = 0) sort_complex(a) 对复数按照先实部后虚部的顺序进行排序。 partition(a, kth[, axis, kind, order]) 指定一个数，对数组进行分区 argpartition(a, kth[, axis, kind, order]) 可以通过关键字 kind 指定算法沿着指定轴对数组进行分区 复数排序： >>> import numpy as np >>> np.sort_complex([5, 3, 6, 2, 1]) array([1.+0.j, 2.+0.j, 3.+0.j, 5.+0.j, 6.+0.j]) >>> np.sort_complex([1 + 2j, 2 - 1j, 3 - 2j, 3 - 3j, 3 + 5j]) array([1.+2.j, 2.-1.j, 3.-3.j, 3.-2.j, 3.+5.j]) partition() 分区排序： >>> a = np.array([3, 4, 2, 1]) >>> np.partition(a, 3) array([2, 1, 3, 4]) >>> np.partition(a, (1, 3)) array([1, 2, 3, 4]) 找到数组的第3小（index=2）的值和第2大（index=-2）的值。 >>> arr = np.array([46, 57, 23, 39, 1, 10, 0, 120]) >>> arr[np.argpartition(arr, 2)[2]] 10 >>> arr[np.argpartition(arr, -2)[-2]] 57 同时找到第3和第4小的值。注意这里，用[2, 3]同时将第3和第4小的排序好，然后可以分别通过下标[2]和[3]取得。 >>> arr[np.argpartition(arr, [2, 3])[2]] 10 >>> arr[np.argpartition(arr, [2, 3])[3]] 23 numpy.argmax() 和 numpy.argmin() numpy.argmax() 和 numpy.argmin() 函数分别沿给定轴返回最大和最小元素的索引。 >>> import numpy as np >>> a = np.array([[30, 40, 70], [80, 20, 10], [50, 90, 60]]) >>> print(a) [[30 40 70] [80 20 10] [50 90 60]] >>> print(np.argmax(a)) 7 >>> print(a.flatten()) [30 40 70 80 20 10 50 90 60] >>> maxindex = np.argmax(a, axis = 1) >>> print(maxindex) [2 0 1] >>> minindex = np.argmin(a) >>> print(minindex) 5 >>> print(a.flatten()[minindex]) 10 >>> minindex = np.argmin(a, axis = 0) >>> print(minindex) [0 1 1] >>> minindex = np.argmin(a, axis = 1) >>> print(minindex) [0 2 0] numpy.nonzero() numpy.nonzero() 函数返回输入数组中非零元素的索引。 >>> import numpy as np >>> a = np.array([[30, 40, 0], [0, 20, 10], [50, 0, 60]]) >>> print(a) [[30 40 0] [ 0 20 10] [50 0 60]] >>> print(np.nonzero(a)) (array([0, 0, 1, 1, 2, 2]), array([0, 1, 1, 2, 0, 2])) numpy.where() numpy.where() 函数返回输入数组中满足给定条件的元素的索引。 >>> import numpy as np >>> x = np.arange(9.).reshape(3, 3) >>> print(x) [[0. 1. 2.] [3. 4. 5.] [6. 7. 8.]] >>> y = np.where(x > 3) >>> print(y) (array([1, 1, 2, 2, 2]), array([1, 2, 0, 1, 2])) >>> print(x[y]) [4. 5. 6. 7. 8.] numpy.extract() numpy.extract() 函数根据某个条件从数组中抽取元素，返回满足条件的元素。 >>> import numpy as np >>> x = np.arange(9.).reshape(3, 3) >>> print(x) [[0. 1. 2.] [3. 4. 5.] [6. 7. 8.]] >>> condition = np.mod(x, 2) == 0 >>> print(condition) [[ True False True] [False True False] [ True False True]] >>> print(np.extract(condition, x)) [0. 2. 4. 6. 8.] "},"chapter_1/1.1.19.Byte_swapping.html":{"url":"chapter_1/1.1.19.Byte_swapping.html","title":"字节交换","keywords":"","body":"字节交换 在几乎所有的的机器上，多字节对象都被存储为连续的字节序列。字节顺序，是跨越多字节的程序对象的存储规则。 大端模式：指数据的高字节保存在内存的低地址中，而数据的低字节保存在内存的高地址中，这样的存储模式有点类似于把数据当作字符串顺序处理：地址由小向大增加，而数据从高位往低位放；这和我们的阅读习惯一致。 小端模式：指数据的高字节保存在内存的高地址中，而数据的的低字节保存在内存的低地址中，这种存储模式将地址的高低和数据位权有效地结合起来，高地址部分权值高，低地址部分权值低。 例如在C语言中，一个类型为int的变量x地址为 0x100，那么其对应地址表达式&x的值为0x100。且x的四个字节将被存储在存储器的0x100，0x101，0x102，0x103位置。 numpy.ndarray.byteswap() numpy.ndarray.byteswap() 函数将 ndarray 中每个元素中的字节进行大小端转换。 >>> import numpy as np >>> a = np.array([1, 256, 8755], dtype = np.int16) >>> print(a) [ 1 256 8755] >>> print(map(hex, a)) >>> print(a.byteswap(True)) [ 256 1 13090] >>> print(map(hex, a)) "},"chapter_1/1.1.20.Copies_and_views.html":{"url":"chapter_1/1.1.20.Copies_and_views.html","title":"副本和视图","keywords":"","body":"副本和视图 副本是一个数据的完整拷贝，如果我们对副本进行修改，他不会影响到原始数据，物理内存不在同一位置。 视图是数据的一个别称或引用，通过该别称或引用亦便可访问、操作原有数据，但原有数据不会产生拷贝。如果我们对视图进行修改，它会影响到原始数据，物理内存在同一位置。 视图一般发生在： numpy 的切片操作返回原数据的视图。 调用 ndarray 的 view() 函数产生一个视图。 副本一般发生在： Python 序列的切片操作，调用 deepCopy() 函数。 调用 ndarray 的 copy() 函数产生一个副本。 无复制 简单的赋值不会创建数组对象的副本。相反，它使用原始数组的相同id()来访问它。id()返回Python对象的通用标识符，类似于C中的指针。 此外，一个数组的任何变化都反映在另一个数组上。例如，一个数组的形状改变也会改变另一个数组的形状。 >>> import numpy as np >>> a = np.arange(6) >>> print(a) [0 1 2 3 4 5] >>> print(id(a)) 140226728682288 >>> b = a >>> print(b) [0 1 2 3 4 5] >>> print(id(b)) 140226728682288 >>> b.shape = 3, 2 >>> print(b) [[0 1] [2 3] [4 5]] >>> print(a) [[0 1] [2 3] [4 5]] 视图和浅拷贝 ndarray.view() 方会创建一个新的数组对象，该方法创建的新数组的维数变化不会改变原始数据的维数。 >>> import numpy as np >>> a = np.arange(6).reshape(3, 2) >>> print(a) [[0 1] [2 3] [4 5]] >>> b = a.view() >>> print(b) [[0 1] [2 3] [4 5]] >>> print(id(a)) 140349686800912 >>> print(id(b)) 140349734824240 >>> b.shape = 2, 3 >>> print(b) [[0 1 2] [3 4 5]] >>> print(a) [[0 1] [2 3] [4 5]] 使用切片创建视图修改数据会影响到原始数组： >>> import numpy as np >>> arr = np.arange(12) >>> print(arr) [ 0 1 2 3 4 5 6 7 8 9 10 11] >>> a = arr[3:] >>> b = arr[3:] >>> a[1] = 123 >>> b[2] = 234 >>> print(arr) [ 0 1 2 3 123 234 6 7 8 9 10 11] >>> print(id(a), id(b), id(arr[3:])) 140335054760240 140335018312208 140335054794896 变量 a,b 都是 arr 的一部分视图，对视图的修改会直接反映到原数据中。但是我们观察 a,b 的 id，他们是不同的，也就是说，视图虽然指向原数据，但是他们和赋值引用还是有区别的。 副本和深拷贝 ndarray.copy() 函数创建一个副本。对副本数据进行修改，不会影响到原始数据，他们物理内存不在同一位置上。 >>> import numpy as np >>> a = np.array([[10, 10], [2, 3], [4, 5]]) >>> print(a) [[10 10] [ 2 3] [ 4 5]] >>> b = a.copy() >>> print(b) [[10 10] [ 2 3] [ 4 5]] >>> print(b is a) False >>> b[0, 0] = 100 >>> print(b) [[100 10] [ 2 3] [ 4 5]] >>> print(a) [[10 10] [ 2 3] [ 4 5]] "},"chapter_1/1.1.21.Matrix.html":{"url":"chapter_1/1.1.21.Matrix.html","title":"矩阵库","keywords":"","body":"矩阵库 NumPy 中包含了一个矩阵库 numpy.matlib，该模块中的函数返回的是一个矩阵，而不是 ndarray 对象。 一个 m×nm \\times n m×n 的矩阵是一个由mmm行（row）nnn列（column）元素排列成的矩形阵列。 矩阵里的元素可以是数字、符号或数学式。以下是一个由6个数字元素构成的2行3列的矩阵： [19−13205−6] \\begin{bmatrix} 1 & 9 & -13 \\\\ 20 & 5 & -6 \\end{bmatrix} [​1​20​​​9​5​​​−13​−6​​] 转置矩阵 NumPy 中除了可以使用 numpy.transpose 函数来对换数组的维度，还可以使用 T 属性。。 例如有个mmm行nnn列的矩阵，使用 t() 函数就能转换为nnn行mmm列的矩阵。 >>> import numpy as np >>> a = np.arange(12).reshape(3, 4) >>> print(a) [[ 0 1 2 3] [ 4 5 6 7] [ 8 9 10 11]] >>> print(a.T) [[ 0 4 8] [ 1 5 9] [ 2 6 10] [ 3 7 11]] numpy.matlib.empty() matlib.empty() 函数返回一个新的矩阵，语法格式为： numpy.matlib.empty(shape, dtype, order) 参数说明： shape：定义新矩阵形状的整数或整数元组 Dtype：可选，数据类型 order：C（行序优先）或者 F（列序优先） >>> import numpy.matlib >>> import numpy as np >>> print(np.matlib.empty((2, 2))) [[0.00000000e+000 2.96174557e-085] [4.48036926e-067 1.41303097e-308]] numpy.matlib.zeros() numpy.matlib.zeros() 函数创建一个以0填充的矩阵。 >>> import numpy.matlib >>> import numpy as np >>> print(np.matlib.zeros((2, 2))) [[0. 0.] [0. 0.]] numpy.matlib.ones() numpy.matlib.ones() 函数创建一个以1填充的矩阵。 >>> import numpy.matlib >>> import numpy as np >>> print(np.matlib.ones((2, 2))) [[1. 1.] [1. 1.]] numpy.matlib.eye() numpy.matlib.eye() 函数返回一个矩阵，对角线元素为1，其他位置为零。 numpy.matlib.eye(n, M, k, dtype) 参数说明： n：返回矩阵的行数 M：返回矩阵的列数，默认为 n k：对角线的索引 dtype: 数据类型 >>> import numpy.matlib >>> import numpy as np >>> print(np.matlib.eye(n = 3, M = 4, k = 0, dtype = float)) [[1. 0. 0. 0.] [0. 1. 0. 0.] [0. 0. 1. 0.]] numpy.matlib.identity() numpy.matlib.identity() 函数返回给定大小的单位矩阵。 单位矩阵式个方阵，从左上角到右下角的对角线（称为主对角线）上的元素均为1，除此之外全都为 0。 >>> import numpy.matlib >>> import numpy as np >>> print(np.matlib.identity(5, dtype = float)) [[1. 0. 0. 0. 0.] [0. 1. 0. 0. 0.] [0. 0. 1. 0. 0.] [0. 0. 0. 1. 0.] [0. 0. 0. 0. 1.]] numpy.matlib.rand() numpy.matlib.rand() 函数创建一个给定大小的矩阵，数据是随机填充的。 >>> import numpy.matlib >>> import numpy as np >>> print(np.matlib.rand(3, 3)) [[0.0848446 0.760929 0.94157133] [0.67884563 0.82797055 0.28249415] [0.02912332 0.18955343 0.08051821]] 矩阵总是二维的，而 ndarray 是一个 n 维数组。两个对象都是可互换的。 >>> import numpy.matlib >>> import numpy as np >>> i = np.matrix('1,2;3,4') >>> print(1) 1 >>> print(i) [[1 2] [3 4]] >>> j = np.asarray(i) >>> print(j) [[1 2] [3 4]] >>> k = np.asmatrix(j) >>> print(k) [[1 2] [3 4]] "},"chapter_1/1.1.22.Linear_algebra.html":{"url":"chapter_1/1.1.22.Linear_algebra.html","title":"线性代数","keywords":"","body":"线性代数 NumPy 提供了线形代数函数库 linalg，该库包含了线性代数所需的所有功能，所以看看下面的说明： 函数 描述 dot 两个数组的点积，即元素对应相乘。 vdot 两个向量的点积 inner 两个数组的内积 matmul 两个数组的矩阵积 determinant 数组的行列式 solve 求解线性矩阵方程 inv 计算矩阵的乘法逆矩阵 numpy.dot() numpy.dot() 对于两个一维的数组，计算的是两个数组对应下标元素的乘积和（数学上称之为内积）；对于二维数组，计算的是两个数组的矩阵乘积；对于多维数组，他的通用计算公式如下，即结果数组中的每个元素都是：数组a的最后一维上的所有元素与数组b的倒数第二位上的所有元素的乘积和：dot(a, b)[i, j, k, m] = sum(a[i, j, :] * b[k, :, m])。 numpy.dot(a, b, out=None) 参数说明： a：ndarray 数组 b：ndarray 数组 out：ndarray，可选，用来保存 dot() 计算结果。 >>> import numpy.matlib >>> import numpy as np >>> a = np.array([[1, 2], [3, 4]]) >>> b = np.array([[11, 12], [13, 14]]) >>> print(np.dot(a, b)) [[37 40] [85 92]] 计算式为： [[1*11+2*13, 1*12+2*14],[3*11+4*13, 3*12+4*14]] numpy.vdot() numpy.vdot() 函数是两个向量的点积。如果第一个参数是复数，那么它的共轭复数会用于计算。如果参数是多维数组，它会被展开。 >>> import numpy as np >>> a = np.array([[1, 2], [3, 4]]) >>> b = np.array([[11, 12], [13, 14]]) >>> print(np.vdot(a, b)) 130 计算式为： 1*11 + 2*12 + 3*13 + 4*14 = 130 numpy.inner() numpy.inner() 函数返回一维数组的向量内积。对于更高的维度，它返回最后一个轴上的和的乘积。 >>> import numpy as np >>> print(np.inner(np.array([1, 2, 3]), np.array([0, 1, 0]))) 2 多维数组示例 >>> import numpy as np >>> a = np.array([[1, 2], [3, 4]]) >>> print(a) [[1 2] [3 4]] >>> b = np.array([[11, 12], [13, 14]]) >>> print(b) [[11 12] [13 14]] >>> print(np.inner(a, b)) [[35 41] [81 95]] 内积计算公式 1*11+2*12, 1*13+2*14 3*11+4*12, 3*13+4*14 numpy.matmul numpy.matmul 函数返回两个数组的矩阵乘积。虽然它返回二维数组的正常乘积，但如果任一参数的维数大于2，则将其视为存在于最后两个索引的矩阵的栈，并进行相应的广播。 另一方面，如果任一参数是一维数组，则通过在其维度上附加1来将其提升为矩阵，并在乘法之后被去除。 对于二维数组，它就是矩阵乘法： >>> import numpy.matlib >>> import numpy as np >>> a = [[1, 0], [0, 1]] >>> b = [[4, 1], [2, 2]] >>> print(np.matmul(a, b)) [[4 1] [2 2]] 二维和一维运算： >>> import numpy.matlib >>> import numpy as np >>> a = [[1, 0], [0, 1]] >>> b = [1, 2] >>> print(np.matmul(a, b)) [1 2] >>> print(np.matmul(b, a)) [1 2] 维度大于二的数组： >>> import numpy.matlib >>> import numpy as np >>> a = np.arange(8).reshape(2, 2, 2) >>> b = np.arange(4).reshape(2, 2) >>> print(np.matmul(a, b)) [[[ 2 3] [ 6 11]] [[10 19] [14 27]]] numpy.linalg.det() numpy.linalg.det() 函数计算输入矩阵的行列式。 行列式在线性代数中是非常有用的值。它从方阵的对角元素计算。对于2x2矩阵，它是左上角和右下角元素的乘积与其他两个的乘积的差。 换句话说，对于矩阵[[a, b], [c, d]]，行列式计算为 ad-bc。较大的方阵被认为是 2x2 矩阵的组合。 >>> import numpy as np >>> a = np.array([[1, 2], [3, 4]]) >>> print(np.linalg.det(a)) -2.0000000000000004 >>> import numpy as np >>> b = np.array([[6, 1, 1], [4, -2, 5], [2, 8, 7]]) >>> print(b) [[ 6 1 1] [ 4 -2 5] [ 2 8 7]] >>> print(np.linalg.det(b)) -306.0 >>> print (6*(-2*7 - 5*8) - 1*(4*7 - 5*2) + 1*(4*8 - -2*2)) -306 numpy.linalg.solve() numpy.linalg.solve() 函数给出了矩阵形式的线性方程的解。 考虑以下线性方式： x + y + z = 6 2y + 5z = -4 2x + 5y - z = 27 可以使用矩阵表示为： 如果矩阵成为A、X和B，方程变为： AX = B 或 X = A^(-1)B numpy.linalg.inv() numpy.linalg.inv() 函数计算矩阵的乘法逆矩阵。 逆矩阵（inverse matrix）：设A是数域上的一个n阶矩阵，若在相同数域上存在另一个n阶矩阵B，使得：AB=BA=E，则我们称B是A的逆矩阵，而A则被称为可逆矩阵。注：E为单位矩阵。 >>> import numpy as np >>> x = np.array([[1, 2], [3, 4]]) >>> y = np.linalg.inv(x) >>> print(x) [[1 2] [3 4]] >>> print(y) [[-2. 1. ] [ 1.5 -0.5]] >>> print(np.dot(x, y)) [[1.0000000e+00 0.0000000e+00] [8.8817842e-16 1.0000000e+00]] 现在创建一个矩阵A的逆矩阵： >>> import numpy as np >>> a = np.array([[1, 1, 1], [0, 2, 5], [2, 5, -1]]) >>> print(a) [[ 1 1 1] [ 0 2 5] [ 2 5 -1]] >>> ainv = np.linalg.inv(a) >>> print(ainv) [[ 1.28571429 -0.28571429 -0.14285714] [-0.47619048 0.14285714 0.23809524] [ 0.19047619 0.14285714 -0.0952381 ]] >>> b = np.array([[6], [-4], [27]]) >>> print(b) [[ 6] [-4] [27]] >>> x = np.linalg.solve(a, b) >>> print(x) [[ 5.] [ 3.] [-2.]] 结果也可以使用以下函数获取： x = np.dot(ainv,b) "},"chapter_1/1.1.23.io.html":{"url":"chapter_1/1.1.23.io.html","title":"IO","keywords":"","body":"IO NumPy 可以读写磁盘上的文本数据或二进制数据。 NumPy 为 ndarray 对象引入了一个简单的文件格式：npy。 npy 文件用于存储重建 ndarray 所需的数据、图形、dtype 和其他信息。 常用的IO函数有： load() 和 save() 函数是读写文件数组数据的两个主要函数，默认情况下，数组是从未压缩的原始二进制格式保存在扩展名为 .npy 的文件中。 savez() 函数用于将多个数组写入文件，默认情况下，数组是从未解压缩的原始二进制格式保存在扩展名为 .npz 的文件中。 loadtxt() 和 savetxt() 函数处理正常的文本文件（.txt等） numpy.save() numpy.save() 函数将数组保存到以 .npy 为扩展名的文件中。 numpy.save(file, arr, allow_pickle=True, fix_imports=True) 参数说明： file：要保存的文件，扩展名为 .npy，如果文件路径末尾没有扩展名 .npy，该扩展名会自动加上。 arr：要保存的数组。 allow_pickle：可选，布尔值，允许使用 Python pickles 保存对象数组，Python 中的 pickle 用于在保存到磁盘文件或从磁盘文件读取之前，对对象进行序列化和反序列化。 fix_imports：可选，为了方便 Python2 中读取 Python3 保存的数据。 import numpy as np a = np.array([1,2,3,4,5]) # 保存到 outfile.npy 文件上 np.save('outfile.npy',a) # 保存到 outfile2.npy 文件上，如果文件路径末尾没有扩展名 .npy，该扩展名会被自动加上 np.save('outfile2',a) 我们可以查看文件内容： $ cat outfile.npy ?NUMPYv{'descr': '可以看出文件是乱码的，因为它们是 NumPy 专用的二进制格式后的数据。 我们可以使用 load() 函数来读取数据就可以正常显示了： import numpy as np b = np.load('outfile.npy') print (b) 输出结果为： [1 2 3 4 5] numpy.savez() numpy.savez() 函数将多个数组保存到以 npz 为扩展名的文件中。 numpy.savez(file, *arg, **kwds) 参数说明： file：要保存的文件，扩展名为.npz，如果文件路径末尾没有扩展名.npz，该扩展名会被自动加上。 args：要保存的数组，可以使用关键字参数为数组起一个名字，非关键字参数传递的数组会自动起名为 arr_0,arr_1,...。 kwds：要保存的数组使用关键字名称。 import numpy as np a = np.array([[1,2,3],[4,5,6]]) b = np.arange(0, 1.0, 0.1) c = np.sin(b) # c 使用了关键字参数 sin_array np.savez(\"runoob.npz\", a, b, sin_array = c) r = np.load(\"runoob.npz\") print(r.files) # 查看各个数组名称 print(r[\"arr_0\"]) # 数组 a print(r[\"arr_1\"]) # 数组 b print(r[\"sin_array\"]) # 数组 c 输出结果： ['sin_array', 'arr_0', 'arr_1'] [[1 2 3] [4 5 6]] [0. 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9] [0. 0.09983342 0.19866933 0.29552021 0.38941834 0.47942554 0.56464247 0.64421769 0.71735609 0.78332691] savetxt() savetxt() 函数是以简单的文本文件格式存储数据，对应的使用 loadtxt() 函数来获取数据。 np.loadtxt(FILENAME, dtype=int, delimiter=' ') np.savetxt(FILENAME, a, fmt=\"%d\", delimiter=\",\") 参数 delimiter 可以指定各种分隔符、针对特定列的转换器函数、需要跳过的行数等。 import numpy as np a = np.array([1,2,3,4,5]) np.savetxt('out.txt',a) b = np.loadtxt('out.txt') print(b) 输出结果为： [1. 2. 3. 4. 5.] 使用 delimiter 参数： import numpy as np a=np.arange(0,10,0.5).reshape(4,-1) np.savetxt(\"out.txt\",a,fmt=\"%d\",delimiter=\",\") # 改为保存为整数，以逗号分隔 b = np.loadtxt(\"out.txt\",delimiter=\",\") # load 时也要指定为逗号分隔 print(b) 输出结果为： [[0. 0. 1. 1. 2.] [2. 3. 3. 4. 4.] [5. 5. 6. 6. 7.] [7. 8. 8. 9. 9.]] "},"chapter_1/1.2.scipy.html":{"url":"chapter_1/1.2.scipy.html","title":"SciPy","keywords":"","body":"1.2 scipy SciPy 是一个开源的 Python 算法库和数学工具包。 SciPy 是基于 NumPy 的科学计算库，用于数学、科学、工程学等领域，很多有一些高阶抽象和物理模型需要使用 SciPy。 SciPy 包含的模块有最优化、线性代数、积分、插值、特殊函数、快速傅立叶变换、信号处理和图像处理、常微分方程求解和其他科学与工程中常用的计算。 NumPy 和 SciPy 的协同工作可以高效解决很多问题。在天文学、生物学、气象学和气候学科，以及材料科学等多个学科得到了广泛应用。 "},"chapter_1/1.2.1.Install.html":{"url":"chapter_1/1.2.1.Install.html","title":"安装","keywords":"","body":"安装 使用 pip 工具来安装 SciPy 库，如果还未安装该工具。 升级 pip: python3 -m pip install -U pip 安装 SciPy 库： python3 -m pip install -U SciPy 安装完成后，我们就可以通过 from scipy import module 来导入 scipy 的库： constants 是 scipy 的常量模块： from scipy import constants 以下实例，我们通过导入 scipy 库，然后查看 scipy 库的版本号： import scipy print(scipy.__version__) 执行以上代码，输出的结果如下： 1.7.1 以下实例，我们通过导入 scipy 的常量模块 constants 来查看一英亩等于多少平方米： from scipy import constants print(constants.acre) 执行以上代码，输出结果如下： 4046.8564223999992 "},"chapter_1/1.2.2.Module.html":{"url":"chapter_1/1.2.2.Module.html","title":"模块","keywords":"","body":"模块 以下列出了 SciPy 常用的一些模块及官网 API 地址： 模块名 功能 参考文档 scipy.cluster 向量量化 cluster API scipy.constants 数学常亮 constants API scipy.fft 快速傅立叶变换 fft API scipy.integrate 积分 integrate API scipy.interpolate 插值 interpolate API scipy.io 数据输入输出 io API scipy.linalg 线性代数 linalg API scipy.misc 图像处理 misc API scipy.ndimage N维图像 ndimage API scipy.odr 正交距离回归 odr API scipy.optimize 优化算法 optimize API scipy.signal 信号处理 signal API scipy.sparse 稀疏矩阵 sparse API scipy.spatial 空间数据结构和算法 spatial API scipy.special 特殊数学函数 special API scipy.stats 统计函数 stats.mstats API 更多模块内容可以参考官方文档：https://docs.scipy.org/doc/scipy/reference/ "},"chapter_1/1.2.3.constants.html":{"url":"chapter_1/1.2.3.constants.html","title":"常量模块","keywords":"","body":"常量模块 SciPy 常量模块 constants 提供了许多内置的数学常数。 圆周率是一个数学常数，为一个圆的周长和其直径的比率，近似值约等于 3.14159，常用符号 π\\piπ 来表示。 以下实例输出圆周率： from scipy import constants print(constants.pi) 执行以上代码，输出结果如下： 3.141592653589793 以下实际输出黄金比例： from scipy import constants print(constants.golden) 执行以上代码，输出结果如下： 1.618033988749895 我们可以使用 dir() 函数来查看 constants 模块包含了那些常量： from scipy import constants print(dir(constants)) 执行以上代码，输出结果如下： ['Avogadro', 'Boltzmann', 'Btu', 'Btu_IT', 'Btu_th', 'ConstantWarning', 'G', 'Julian_year', 'N_A', 'Planck', 'R', 'Rydberg', 'Stefan_Boltzmann', 'Wien', '__all__', '__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__path__', '__spec__', '_obsolete_constants', 'acre', 'alpha', 'angstrom', 'arcmin', 'arcminute', 'arcsec', 'arcsecond', 'astronomical_unit', 'atm', 'atmosphere', 'atomic_mass', 'atto', 'au', 'bar', 'barrel', 'bbl', 'blob', 'c', 'calorie', 'calorie_IT', 'calorie_th', 'carat', 'centi', 'codata', 'constants', 'convert_temperature', 'day', 'deci', 'degree', 'degree_Fahrenheit', 'deka', 'dyn', 'dyne', 'e', 'eV', 'electron_mass', 'electron_volt', 'elementary_charge', 'epsilon_0', 'erg', 'exa', 'exbi', 'femto', 'fermi', 'find', 'fine_structure', 'fluid_ounce', 'fluid_ounce_US', 'fluid_ounce_imp', 'foot', 'g', 'gallon', 'gallon_US', 'gallon_imp', 'gas_constant', 'gibi', 'giga', 'golden', 'golden_ratio', 'grain', 'gram', 'gravitational_constant', 'h', 'hbar', 'hectare', 'hecto', 'horsepower', 'hour', 'hp', 'inch', 'k', 'kgf', 'kibi', 'kilo', 'kilogram_force', 'kmh', 'knot', 'lambda2nu', 'lb', 'lbf', 'light_year', 'liter', 'litre', 'long_ton', 'm_e', 'm_n', 'm_p', 'm_u', 'mach', 'mebi', 'mega', 'metric_ton', 'micro', 'micron', 'mil', 'mile', 'milli', 'minute', 'mmHg', 'mph', 'mu_0', 'nano', 'nautical_mile', 'neutron_mass', 'nu2lambda', 'ounce', 'oz', 'parsec', 'pebi', 'peta', 'physical_constants', 'pi', 'pico', 'point', 'pound', 'pound_force', 'precision', 'proton_mass', 'psi', 'pt', 'short_ton', 'sigma', 'slinch', 'slug', 'speed_of_light', 'speed_of_sound', 'stone', 'survey_foot', 'survey_mile', 'tebi', 'tera', 'test', 'ton_TNT', 'torr', 'troy_ounce', 'troy_pound', 'u', 'unit', 'value', 'week', 'yard', 'year', 'yobi', 'yotta', 'zebi', 'zepto', 'zero_Celsius', 'zetta'] 单位类型 常量模块包含以下几种单位： 公制单位 二进制，以字节为单位 质量单位 角度换算 时间单位 长度单位 压强单位 面积单位 体积单位 速度单位 温度单位 能量单位 功率单位 力学单位 国际单位制词头 国际单位制词头（英语：SI prefix）表示单位的倍数和分数，目前有20个词头，大多数是千的整数次幂。（centi 返回 0.01）： 词头 次幂 yotta 102410^{24}10​24​​ zetta 102110^{21}10​21​​ exa 101810^{18}10​18​​ peta 101510^{15}10​15​​ tera 101210^{12}10​12​​ giga 10910^{9}10​9​​ mega 10610^{6}10​6​​ kilo 10310^{3}10​3​​ hecto 10210^{2}10​2​​ deka 10110^{1}10​1​​ deci 10−110^{-1}10​−1​​ centi 10−210^{-2}10​−2​​ milli 10−310^{-3}10​−3​​ micro 10−610^{-6}10​−6​​ nano 10−910^{-9}10​−9​​ pico 10−1210^{-12}10​−12​​ femto 10−1510^{-15}10​−15​​ atto 10−1810^{-18}10​−18​​ zepto 10−2110^{-21}10​−21​​ from scipy import constants print(constants.yotta) #1e+24 print(constants.zetta) #1e+21 print(constants.exa) #1e+18 print(constants.peta) #1000000000000000.0 print(constants.tera) #1000000000000.0 print(constants.giga) #1000000000.0 print(constants.mega) #1000000.0 print(constants.kilo) #1000.0 print(constants.hecto) #100.0 print(constants.deka) #10.0 print(constants.deci) #0.1 print(constants.centi) #0.01 print(constants.milli) #0.001 print(constants.micro) #1e-06 print(constants.nano) #1e-09 print(constants.pico) #1e-12 print(constants.femto) #1e-15 print(constants.atto) #1e-18 print(constants.zepto) #1e-21 二进制前缀 返回字节单位（kibi 返回 1024）. 字节单位 次幂 kibi 2102^{10}2​10​​ mebi 2202^{20}2​20​​ gibi 2302^{30}2​30​​ tebi 2402^{40}2​40​​ pebi 2502^{50}2​50​​ exbi 2602^{60}2​60​​ zebi 2702^{70}2​70​​ yobi 2802^{80}2​80​​ from scipy import constants print(constants.kibi) #1024 print(constants.mebi) #1048576 print(constants.gibi) #1073741824 print(constants.tebi) #1099511627776 print(constants.pebi) #1125899906842624 print(constants.exbi) #1152921504606846976 print(constants.zebi) #1180591620717411303424 print(constants.yobi) #1208925819614629174706176 质量单位 返回多少千克。（gram 返回 0.001） from scipy import constants print(constants.gram) #0.001 print(constants.metric_ton) #1000.0 print(constants.grain) #6.479891e-05 print(constants.lb) #0.45359236999999997 print(constants.pound) #0.45359236999999997 print(constants.oz) #0.028349523124999998 print(constants.ounce) #0.028349523124999998 print(constants.stone) #6.3502931799999995 print(constants.long_ton) #1016.0469088 print(constants.short_ton) #907.1847399999999 print(constants.troy_ounce) #0.031103476799999998 print(constants.troy_pound) #0.37324172159999996 print(constants.carat) #0.0002 print(constants.atomic_mass) #1.66053904e-27 print(constants.m_u) #1.66053904e-27 print(constants.u) #1.66053904e-27 角度单位 返回弧度。（degree 返回 0.017453292519943295） from scipy import constants print(constants.degree) #0.017453292519943295 print(constants.arcmin) #0.0002908882086657216 print(constants.arcminute) #0.0002908882086657216 print(constants.arcsec) #4.84813681109536e-06 print(constants.arcsecond) #4.84813681109536e-06 时间单位 返回秒数。（hour 返回 3600.0） from scipy import constants print(constants.minute) #60.0 print(constants.hour) #3600.0 print(constants.day) #86400.0 print(constants.week) #604800.0 print(constants.year) #31536000.0 print(constants.Julian_year) #31557600.0 长度单位 返回米数(nautical_mile 返回 1852.0)。 from scipy import constants print(constants.inch) #0.0254 print(constants.foot) #0.30479999999999996 print(constants.yard) #0.9143999999999999 print(constants.mile) #1609.3439999999998 print(constants.mil) #2.5399999999999997e-05 print(constants.pt) #0.00035277777777777776 print(constants.point) #0.00035277777777777776 print(constants.survey_foot) #0.3048006096012192 print(constants.survey_mile) #1609.3472186944373 print(constants.nautical_mile) #1852.0 print(constants.fermi) #1e-15 print(constants.angstrom) #1e-10 print(constants.micron) #1e-06 print(constants.au) #149597870691.0 print(constants.astronomical_unit) #149597870691.0 print(constants.light_year) #9460730472580800.0 print(constants.parsec) #3.0856775813057292e+16 压强单位 返回多少帕斯卡，压力的 SI 制单位。(psi 返回 6894.757293168361)。 from scipy import constants print(constants.atm) #101325.0 print(constants.atmosphere) #101325.0 print(constants.bar) #100000.0 print(constants.torr) #133.32236842105263 print(constants.mmHg) #133.32236842105263 print(constants.psi) #6894.757293168361 面积单位 返回多少平方米，平方米是面积的公制单位，其定义是：在一平面上，边长为一米的正方形之面积。(hectare 返回 10000.0)。 from scipy import constants print(constants.hectare) #10000.0 print(constants.acre) #4046.8564223999992 体积单位 返回多少立方米，立方米容量计量单位，1 立方米的容量相当于一个长、宽、高都等于 1 米的立方体的体积，与 1 公秉和 1 度水的容积相等，也与1000000立方厘米的体积相等。(liter 返回 0.001)。 from scipy import constants print(constants.liter) #0.001 print(constants.litre) #0.001 print(constants.gallon) #0.0037854117839999997 print(constants.gallon_US) #0.0037854117839999997 print(constants.gallon_imp) #0.00454609 print(constants.fluid_ounce) #2.9573529562499998e-05 print(constants.fluid_ounce_US) #2.9573529562499998e-05 print(constants.fluid_ounce_imp) #2.84130625e-05 print(constants.barrel) #0.15898729492799998 print(constants.bbl) #0.15898729492799998 速度单位 返回每秒多少米。(speed_of_sound 返回 340.5)。 from scipy import constants print(constants.kmh) #0.2777777777777778 print(constants.mph) #0.44703999999999994 print(constants.mach) #340.5 print(constants.speed_of_sound) #340.5 print(constants.knot) #0.5144444444444445 温度单位 返回多少开尔文。(zero_Celsius 返回 273.15)。 from scipy import constants print(constants.zero_Celsius) #273.15 print(constants.degree_Fahrenheit) #0.5555555555555556 能量单位 返回多少焦耳，焦耳（简称焦）是国际单位制中能量、功或热量的导出单位，符号为J。(calorie 返回 4.184)。 from scipy import constants print(constants.zero_Celsius) #273.15 print(constants.degree_Fahrenheit) #0.5555555555555556 功率单位 返回多少瓦特，瓦特（符号：W）是国际单位制的功率单位。1瓦特的定义是1焦耳/秒（1 J/s），即每秒钟转换，使用或耗散的（以安培为量度的）能量的速率。(horsepower 返回 745.6998715822701)。 from scipy import constants print(constants.hp) #745.6998715822701 print(constants.horsepower) #745.6998715822701 力学单位 返回多少牛顿，牛顿（符号为N，英语：Newton）是一种物理量纲，是力的公制单位。它是以建立经典力学（经典力学）的艾萨克·牛顿命名。。(kilogram_force 返回 9.80665)。 from scipy import constants print(constants.dyn) #1e-05 print(constants.dyne) #1e-05 print(constants.lbf) #4.4482216152605 print(constants.pound_force) #4.4482216152605 print(constants.kgf) #9.80665 print(constants.kilogram_force) #9.80665 "},"chapter_1/1.2.4.Optimize.html":{"url":"chapter_1/1.2.4.Optimize.html","title":"优化器","keywords":"","body":"优化器 SciPy 的 optimize 模块提供了常用的最优化算法函数实现，我们可以直接调用这些函数完成我们的优化问题，比如查找函数的最小值或方程的根等。 NumPy 能够找到多项式和线性方程的根，但它无法找到非线形方程的根，如下所示： x + cos(x) 因此我们可以使用 SciPy 的 optimze.root 函数，这个函数需要两个参数： fun - 表示方程的函数。 x0 - 根的初始猜测。 该函数返回一个对象，其中包含有关解决方案的信息。 实际解决方案在返回对象的属性x，查看如下实例： 查找 x + cos(x) 方程的根： from scipy.optimize import root from math import cos def eqn(x): return x + cos(x) myroot = root(eqn, 0) print(myroot.x) # 输出更多信息 print(myroot) "},"chapter_1/1.3.pandas.html":{"url":"chapter_1/1.3.pandas.html","title":"Pandas","keywords":"","body":"1.3 pandas "},"chapter_1/1.4.matplotlib.html":{"url":"chapter_1/1.4.matplotlib.html","title":"matplotlib","keywords":"","body":"1.4 matplotlib "}}